{
  "version": 3,
  "sources": ["../src/index.ts", "../src/deobfuscator.ts", "../src/util/types.ts", "../src/context.ts", "../src/transformers/transformer.ts", "../src/util/walk.ts", "../src/util/guard.ts", "../src/util/helpers.ts", "../src/transformers/controlflow.ts", "../src/transformers/desequence.ts", "../src/transformers/literalmap.ts", "../src/transformers/memberexpressioncleaner.ts", "../src/util/translator.ts", "../src/util/math.ts", "../src/transformers/simplify.ts", "../src/transformers/stringdecoder.ts", "../src/transformers/deadcode.ts", "../src/transformers/demangle.ts", "../src/transformers/arraymap.ts", "../src/transformers/rename.ts", "../src/util/words.ts", "../src/transformers/jsconfuser/calculator.ts", "../src/transformers/jsconfuser/controlflow.ts"],
  "sourcesContent": ["import { Deobfuscator, DeobfuscateOptions } from './deobfuscator'\r\nimport { Transformer, TransformerOptions } from './transformers/transformer'\r\n\r\nexport { Deobfuscator, DeobfuscateOptions, Transformer, TransformerOptions }\r\n", "import escodegen from '@javascript-obfuscator/escodegen'\r\nimport * as acorn from 'acorn' // no, it cannot be a default import\r\nimport * as acornLoose from 'acorn-loose'\r\nimport { Transformer, TransformerOptions } from './transformers/transformer'\r\nimport { Node, Program, sp } from './util/types'\r\nimport Context from './context'\r\nimport prettier from 'prettier'\r\nimport { walk } from './util/walk'\r\n\r\nconst FILE_REGEX = /(?<!\\.d)\\.[mc]?[jt]s$/i // cjs, mjs, js, ts, but no .d.ts\r\n\r\n// TODO: remove this when https://github.com/acornjs/acorn/commit/a4a5510 lands\r\ntype ecmaVersion =\r\n  | 3\r\n  | 5\r\n  | 6\r\n  | 7\r\n  | 8\r\n  | 9\r\n  | 10\r\n  | 11\r\n  | 12\r\n  | 13\r\n  | 2015\r\n  | 2016\r\n  | 2017\r\n  | 2018\r\n  | 2019\r\n  | 2020\r\n  | 2021\r\n  | 2022\r\n  | 'latest'\r\n\r\ntype TransformerArray = [string, Partial<TransformerOptions>][]\r\n\r\nexport interface DeobfuscateOptions {\r\n  /**\r\n   * ECMA version to use when parsing AST (see acorn, default = 'latest')\r\n   */\r\n  ecmaVersion: ecmaVersion\r\n\r\n  /**\r\n   * Replace ChainExpressions with babel-compatible Optional{X}Expessions\r\n   * for work with Prettier\r\n   * https://github.com/prettier/prettier/pull/12172\r\n   * (default = true)\r\n   */\r\n  transformChainExpressions: boolean\r\n\r\n  /**\r\n   * Custom transformers to use\r\n   */\r\n  customTransformers: TransformerArray\r\n\r\n  /**\r\n   * Rename identifiers (default = false)\r\n   */\r\n  rename: boolean\r\n\r\n  /**\r\n   * Acorn source type\r\n   */\r\n  sourceType: 'module' | 'script'\r\n\r\n  /**\r\n   * Loose parsing (default = false)\r\n   */\r\n  loose: boolean\r\n}\r\n\r\nfunction sourceHash(str: string) {\r\n  let key = 0x94a3fa21\r\n  let length = str.length\r\n  while (length) key = (key * 33) ^ str.charCodeAt(--length)\r\n  return key >>> 0\r\n}\r\n\r\nexport class Deobfuscator {\r\n  public defaultOptions: DeobfuscateOptions = {\r\n    ecmaVersion: 'latest',\r\n    transformChainExpressions: true,\r\n    customTransformers: [],\r\n    rename: false,\r\n    sourceType: 'module',\r\n    loose: false,\r\n  }\r\n\r\n  private buildOptions(\r\n    options: Partial<DeobfuscateOptions> = {}\r\n  ): DeobfuscateOptions {\r\n    return { ...this.defaultOptions, ...options }\r\n  }\r\n\r\n  private buildAcornOptions(options: DeobfuscateOptions): acorn.Options {\r\n    return {\r\n      ecmaVersion: options.ecmaVersion,\r\n      sourceType: options.sourceType,\r\n      // this is important for eslint-scope !!!!!!\r\n      ranges: true,\r\n    }\r\n  }\r\n\r\n  private parse(\r\n    input: string,\r\n    options: acorn.Options,\r\n    deobfOptions: DeobfuscateOptions\r\n  ): acorn.Node {\r\n    return (deobfOptions.loose ? acornLoose : acorn).parse(input, options)\r\n  }\r\n\r\n  public async deobfuscateNode(\r\n    node: Program,\r\n    _options?: Partial<DeobfuscateOptions>\r\n  ): Promise<Program> {\r\n    const options = this.buildOptions(_options)\r\n\r\n    const defaultTransformers: TransformerArray = [\r\n      ['Simplify', {}],\r\n      ['MemberExpressionCleaner', {}],\r\n      ['LiteralMap', {}],\r\n      ['DeadCode', {}],\r\n      ['Demangle', {}],\r\n\r\n      ['StringDecoder', {}],\r\n\r\n      ['Simplify', {}],\r\n      ['MemberExpressionCleaner', {}],\r\n\r\n      ['Desequence', {}],\r\n      ['ControlFlow', {}],\r\n      ['Desequence', {}],\r\n      ['MemberExpressionCleaner', {}],\r\n\r\n      //['ArrayMap', {}],\r\n      ['Simplify', {}],\r\n      ['DeadCode', {}],\r\n      ['Simplify', {}],\r\n      ['DeadCode', {}],\r\n    ]\r\n\r\n    let context = new Context(\r\n      node,\r\n      options.customTransformers.length > 0\r\n        ? options.customTransformers\r\n        : defaultTransformers,\r\n      options.sourceType === 'module'\r\n    )\r\n\r\n    for (const t of context.transformers) {\r\n      console.log('Running', t.name, 'transformer')\r\n      await t.transform(context)\r\n    }\r\n\r\n    if (options.rename) {\r\n      let source = escodegen.generate(context.ast, {\r\n          sourceMapWithCode: true,\r\n        }).code,\r\n        parsed = this.parse(\r\n          source,\r\n          this.buildAcornOptions(options),\r\n          options\r\n        ) as Program\r\n      context = new Context(\r\n        parsed,\r\n        [['Rename', {}]],\r\n        options.sourceType === 'module'\r\n      )\r\n      context.hash = sourceHash(source)\r\n      for (const t of context.transformers) {\r\n        console.log('(rename) Running', t.name, 'transformer')\r\n        await t.transform(context)\r\n      }\r\n    }\r\n\r\n    return context.ast\r\n  }\r\n\r\n  public async deobfuscateSource(\r\n    source: string,\r\n    _options?: Partial<DeobfuscateOptions>\r\n  ): Promise<string> {\r\n    const options = this.buildOptions(_options)\r\n    const acornOptions = this.buildAcornOptions(options)\r\n    let ast = this.parse(source, acornOptions, options) as Program\r\n\r\n    // perform transforms\r\n    ast = await this.deobfuscateNode(ast, options)\r\n\r\n    source = escodegen.generate(ast, {\r\n      sourceMapWithCode: true,\r\n    }).code\r\n    try {\r\n      source = prettier.format(source, {\r\n        semi: false,\r\n        singleQuote: true,\r\n\r\n        // https://github.com/prettier/prettier/pull/12172\r\n        parser: (text, _opts) => {\r\n          let ast = this.parse(text, acornOptions, options)\r\n          if (options.transformChainExpressions) {\r\n            walk(ast as Node, {\r\n              ChainExpression(cx) {\r\n                if (cx.expression.type === 'CallExpression') {\r\n                  sp<any>(cx, {\r\n                    ...cx.expression,\r\n                    type: 'OptionalCallExpression',\r\n                    expression: undefined,\r\n                  })\r\n                } else if (cx.expression.type === 'MemberExpression') {\r\n                  sp<any>(cx, {\r\n                    ...cx.expression,\r\n                    type: 'OptionalMemberExpression',\r\n                    expression: undefined,\r\n                  })\r\n                }\r\n              },\r\n            })\r\n          }\r\n          return ast\r\n        },\r\n      })\r\n    } catch (err) {\r\n      // I don't think we should log here, but throwing the error is not very\r\n      // important since it is non fatal\r\n      console.log(err)\r\n    }\r\n\r\n    return source\r\n  }\r\n}\r\n", "import * as ESTree from 'estree'\r\n\r\n// this setprop func is really bad but typescript is also really bad so its okay\r\n/**\r\n * Update properties on node\r\n * @param node AST node\r\n * @param props kv to update\r\n */\r\nexport function sp<T extends ESTree.Node>(\r\n  node: ASTNode<any>,\r\n  props: Partial<ASTNode<T>>\r\n): node is ASTNode<T> {\r\n  for (const key in props) {\r\n    ;(node as any)[key] = props[key as keyof ASTNode<T>]\r\n  }\r\n  return true\r\n}\r\n\r\nexport function getBlockId(node: BlockStatement): BlockId {\r\n  return [node.start, node.end].join('!')\r\n}\r\n\r\nexport type BlockId = string\r\n\r\nexport type NodeType = ESTree.Node['type']\r\nexport type NodeByType<T extends NodeType> = ASTNode<\r\n  Extract<ESTree.Node, { type: T }>\r\n>\r\n\r\n// This does not seem to work on Union types (e.g. Node | undefined | null)\r\n// or arrays. This should be fixed.\r\n\r\n// ASTNode is expanded upon from github.com/RReverser (Ingvar Stepanyan)'s work\r\n// at https://github.com/acornjs/acorn/issues/946#issuecomment-610074010\r\nexport type ASTNode<TType> = {\r\n  [K in keyof TType]: TType[K] extends object ? ASTNode<TType[K]> : TType[K]\r\n} & (TType extends ESTree.Node\r\n  ? {\r\n      start: number\r\n      end: number\r\n    }\r\n  : {})\r\n\r\n// .map(i=>{\r\n//   a=i.split('.');\r\n//   return `export type ${a[1]} = ASTNode<${a.join('.')}>`\r\n// }).join('\\n')\r\nexport type BinaryOperator = ESTree.BinaryOperator\r\n\r\nexport type Node = ASTNode<ESTree.Node>\r\nexport type Identifier = ASTNode<ESTree.Identifier>\r\n\r\nexport type Literal = ASTNode<ESTree.Literal>\r\nexport type SimpleLiteral = ASTNode<ESTree.SimpleLiteral>\r\nexport type RegExpLiteral = ASTNode<ESTree.RegExpLiteral>\r\nexport type BigIntLiteral = ASTNode<ESTree.BigIntLiteral>\r\n\r\nexport type Program = ASTNode<ESTree.Program>\r\n\r\nexport type Function = ASTNode<ESTree.Function>\r\nexport type FunctionDeclaration = ASTNode<ESTree.FunctionDeclaration>\r\nexport type FunctionExpression = ASTNode<ESTree.FunctionExpression>\r\nexport type ArrowFunctionExpression = ASTNode<ESTree.ArrowFunctionExpression>\r\n\r\nexport type SwitchCase = ASTNode<ESTree.SwitchCase>\r\n\r\nexport type CatchClause = ASTNode<ESTree.CatchClause>\r\n\r\nexport type VariableDeclarator = ASTNode<ESTree.VariableDeclarator>\r\n\r\nexport type Statement = ASTNode<ESTree.Statement>\r\nexport type ExpressionStatement = ASTNode<ESTree.ExpressionStatement>\r\nexport type BlockStatement = ASTNode<ESTree.BlockStatement>\r\nexport type StaticBlock = ASTNode<ESTree.StaticBlock>\r\nexport type EmptyStatement = ASTNode<ESTree.EmptyStatement>\r\nexport type DebuggerStatement = ASTNode<ESTree.DebuggerStatement>\r\nexport type WithStatement = ASTNode<ESTree.WithStatement>\r\nexport type ReturnStatement = ASTNode<ESTree.ReturnStatement>\r\nexport type LabeledStatement = ASTNode<ESTree.LabeledStatement>\r\nexport type BreakStatement = ASTNode<ESTree.BreakStatement>\r\nexport type ContinueStatement = ASTNode<ESTree.ContinueStatement>\r\nexport type IfStatement = ASTNode<ESTree.IfStatement>\r\nexport type SwitchStatement = ASTNode<ESTree.SwitchStatement>\r\nexport type ThrowStatement = ASTNode<ESTree.ThrowStatement>\r\nexport type TryStatement = ASTNode<ESTree.TryStatement>\r\nexport type WhileStatement = ASTNode<ESTree.WhileStatement>\r\nexport type DoWhileStatement = ASTNode<ESTree.DoWhileStatement>\r\nexport type ForStatement = ASTNode<ESTree.ForStatement>\r\nexport type ForInStatement = ASTNode<ESTree.ForInStatement>\r\nexport type ForOfStatement = ASTNode<ESTree.ForOfStatement>\r\nexport type VariableDeclaration = ASTNode<ESTree.VariableDeclaration>\r\nexport type ClassDeclaration = ASTNode<ESTree.ClassDeclaration>\r\n\r\nexport type Expression = ASTNode<ESTree.Expression>\r\nexport type ThisExpression = ASTNode<ESTree.ThisExpression>\r\nexport type ArrayExpression = ASTNode<ESTree.ArrayExpression>\r\nexport type ObjectExpression = ASTNode<ESTree.ObjectExpression>\r\nexport type YieldExpression = ASTNode<ESTree.YieldExpression>\r\nexport type UnaryExpression = ASTNode<ESTree.UnaryExpression>\r\nexport type UpdateExpression = ASTNode<ESTree.UpdateExpression>\r\nexport type BinaryExpression = ASTNode<ESTree.BinaryExpression>\r\nexport type AssignmentExpression = ASTNode<ESTree.AssignmentExpression>\r\nexport type LogicalExpression = ASTNode<ESTree.LogicalExpression>\r\nexport type MemberExpression = ASTNode<ESTree.MemberExpression>\r\nexport type ConditionalExpression = ASTNode<ESTree.ConditionalExpression>\r\nexport type SimpleCallExpression = ASTNode<ESTree.SimpleCallExpression>\r\nexport type NewExpression = ASTNode<ESTree.NewExpression>\r\nexport type SequenceExpression = ASTNode<ESTree.SequenceExpression>\r\nexport type TemplateLiteral = ASTNode<ESTree.TemplateLiteral>\r\nexport type TaggedTemplateExpression = ASTNode<ESTree.TaggedTemplateExpression>\r\nexport type ClassExpression = ASTNode<ESTree.ClassExpression>\r\nexport type MetaProperty = ASTNode<ESTree.MetaProperty>\r\nexport type AwaitExpression = ASTNode<ESTree.AwaitExpression>\r\nexport type ImportExpression = ASTNode<ESTree.ImportExpression>\r\nexport type ChainExpression = ASTNode<ESTree.ChainExpression>\r\n\r\nexport type PrivateIdentifier = ASTNode<ESTree.PrivateIdentifier>\r\nexport type Property = ASTNode<ESTree.Property>\r\nexport type PropertyDefinition = ASTNode<ESTree.PropertyDefinition>\r\nexport type AssignmentProperty = ASTNode<ESTree.AssignmentProperty>\r\nexport type Super = ASTNode<ESTree.Super>\r\nexport type TemplateElement = ASTNode<ESTree.TemplateElement>\r\nexport type SpreadElement = ASTNode<ESTree.SpreadElement>\r\nexport type ObjectPattern = ASTNode<ESTree.ObjectPattern>\r\nexport type ArrayPattern = ASTNode<ESTree.ArrayPattern>\r\nexport type RestElement = ASTNode<ESTree.RestElement>\r\nexport type AssignmentPattern = ASTNode<ESTree.AssignmentPattern>\r\n\r\nexport type ClassBody = ASTNode<ESTree.ClassBody>\r\n\r\nexport type MethodDefinition = ASTNode<ESTree.MethodDefinition>\r\nexport type ImportDeclaration = ASTNode<ESTree.ImportDeclaration>\r\nexport type ExportNamedDeclaration = ASTNode<ESTree.ExportNamedDeclaration>\r\nexport type ExportDefaultDeclaration = ASTNode<ESTree.ExportDefaultDeclaration>\r\nexport type ExportAllDeclaration = ASTNode<ESTree.ExportAllDeclaration>\r\nexport type ImportSpecifier = ASTNode<ESTree.ImportSpecifier>\r\nexport type ImportDefaultSpecifier = ASTNode<ESTree.ImportDefaultSpecifier>\r\nexport type ImportNamespaceSpecifier = ASTNode<ESTree.ImportNamespaceSpecifier>\r\nexport type ExportSpecifier = ASTNode<ESTree.ExportSpecifier>\r\n\r\nexport type Pattern = ASTNode<ESTree.Pattern>\r\nexport type CallExpression = ASTNode<ESTree.CallExpression>\r\n\r\n// Custom typed nodes for typeguards\r\nexport type PropertyLiteral = Property & {\r\n  key: Literal\r\n}\r\n\r\nexport type StringLiteral = Literal & { value: string }\r\nexport type NumericLiteral = Literal & { value: number }\r\nexport type BooleanLiteral = Literal & { value: boolean }\r\nexport type NumericUnaryExpression = UnaryExpression & {\r\n  argument: NumericLiteral\r\n}\r\n", "import {\r\n  Node,\r\n  BinaryOperator,\r\n  BlockId,\r\n  FunctionExpression,\r\n  Program,\r\n} from './util/types'\r\nimport { Transformer, TransformerOptions } from './transformers/transformer'\r\n\r\nimport * as eslintScope from 'eslint-scope'\r\n\r\nimport ControlFlow from './transformers/controlflow'\r\nimport Desequence from './transformers/desequence'\r\nimport LiteralMap from './transformers/literalmap'\r\nimport MemberExpressionCleaner from './transformers/memberexpressioncleaner'\r\nimport Simplify from './transformers/simplify'\r\nimport StringDecoder from './transformers/stringdecoder'\r\nimport DeadCode from './transformers/deadcode'\r\nimport Demangle from './transformers/demangle'\r\nimport ArrayMap from './transformers/arraymap'\r\nimport Rename from './transformers/rename'\r\nimport JSCCalculator from './transformers/jsconfuser/calculator'\r\nimport JSCControlFlow from './transformers/jsconfuser/controlflow'\r\n\r\nexport enum DecoderFunctionType {\r\n  SIMPLE,\r\n  BASE64,\r\n  RC4,\r\n}\r\n\r\nexport interface DecoderFunction {\r\n  identifier: string\r\n  stringArrayIdentifier: string\r\n  type: DecoderFunctionType\r\n  offset: number\r\n  indexArgument: number\r\n  keyArgument: number\r\n}\r\n\r\nexport interface DecoderFunctionSimple extends DecoderFunction {\r\n  type: DecoderFunctionType.SIMPLE\r\n}\r\n\r\nexport interface DecoderFunctionBase64 extends DecoderFunction {\r\n  type: DecoderFunctionType.BASE64\r\n  charset: string\r\n}\r\n\r\nexport interface DecoderFunctionRC4 extends DecoderFunction {\r\n  type: DecoderFunctionType.RC4\r\n  charset: string\r\n}\r\n\r\nexport interface DecoderReference {\r\n  identifier: string\r\n  realIdentifier: string\r\n  additionalOffset: number\r\n\r\n  // if the wrapper is a function\r\n  indexArgument?: number\r\n  keyArgument?: number\r\n}\r\n\r\ninterface ControlFlowFunction {\r\n  identifier: string\r\n  node: FunctionExpression\r\n}\r\ninterface ControlFlowLiteral {\r\n  identifier: string\r\n  value: string | number\r\n}\r\ninterface ControlFlowStorage {\r\n  identifier: string\r\n  aliases: string[]\r\n  functions: ControlFlowFunction[]\r\n  literals: ControlFlowLiteral[]\r\n}\r\n\r\nexport enum StringArrayType {\r\n  FUNCTION,\r\n  ARRAY,\r\n}\r\n\r\ninterface StringArray {\r\n  identifier: string\r\n  type: StringArrayType\r\n  strings: string[]\r\n}\r\n\r\nexport default class Context {\r\n  ast: Program\r\n  source?: string\r\n\r\n  shiftedArrays: number = 0\r\n  stringArrays: StringArray[] = []\r\n  stringDecoders: DecoderFunction[] = []\r\n  stringDecoderReferences: DecoderReference[] = []\r\n\r\n  controlFlowStorageNodes: {\r\n    [x: BlockId]: ControlFlowStorage\r\n  } = {}\r\n\r\n  removeGarbage: boolean = true\r\n  transformers: InstanceType<typeof Transformer>[]\r\n\r\n  enableLog: boolean = true\r\n\r\n  scopeManager: eslintScope.ScopeManager\r\n  hash: number = 0\r\n\r\n  constructor(\r\n    ast: Program,\r\n    transformers: [string, Partial<TransformerOptions>][],\r\n    isModule: boolean,\r\n    source?: string,\r\n  ) {\r\n    this.ast = ast\r\n    this.transformers = this.buildTransformerList(transformers)\r\n\r\n    this.source = source\r\n\r\n    this.scopeManager = eslintScope.analyze(this.ast, {\r\n      sourceType: isModule ? 'module' : 'script',\r\n    })\r\n  }\r\n\r\n  public log(message?: any, ...optionalParams: any[]) {\r\n    if (!this.enableLog) return\r\n    console.log(message, ...optionalParams)\r\n  }\r\n\r\n  private buildTransformerList(\r\n    list: [string, Partial<TransformerOptions>][]\r\n  ): InstanceType<typeof Transformer>[] {\r\n    let transformers: InstanceType<typeof Transformer>[] = []\r\n    for (let [name, opt] of list) {\r\n      switch (name.toLowerCase()) {\r\n        case 'controlflow':\r\n          transformers.push(new ControlFlow(opt))\r\n          break\r\n        case 'desequence':\r\n          transformers.push(new Desequence(opt))\r\n          break\r\n        case 'literalmap':\r\n          transformers.push(new LiteralMap(opt))\r\n          break\r\n        case 'memberexpressioncleaner':\r\n          transformers.push(new MemberExpressionCleaner(opt))\r\n          break\r\n        case 'simplify':\r\n          transformers.push(new Simplify(opt))\r\n          break\r\n        case 'stringdecoder':\r\n          transformers.push(new StringDecoder(opt))\r\n          break\r\n        case 'deadcode':\r\n          transformers.push(new DeadCode(opt))\r\n          break\r\n        case 'demangle':\r\n          transformers.push(new Demangle(opt))\r\n          break\r\n        case 'arraymap':\r\n          transformers.push(new ArrayMap(opt))\r\n          break\r\n        case 'rename':\r\n          transformers.push(new Rename(opt))\r\n          break\r\n        case 'jsc-calculator':\r\n          transformers.push(new JSCCalculator(opt))\r\n          break\r\n        case 'jsc-controlflow':\r\n          transformers.push(new JSCControlFlow(opt))\r\n          break\r\n        default:\r\n          throw new TypeError(\r\n            `Transformer \"${name}\" is invalid, it does not exist`\r\n          )\r\n      }\r\n    }\r\n    return transformers\r\n  }\r\n}\r\n", "import Context from '../context'\r\n\r\nexport interface TransformerOptions {}\r\nexport abstract class Transformer<TOptions extends TransformerOptions> {\r\n  name: string\r\n  options: TOptions\r\n\r\n  constructor(name: string, options: Partial<TOptions>) {\r\n    this.name = name\r\n    this.options = this.buildOptions(options)\r\n  }\r\n\r\n  protected buildOptions(options: Partial<TOptions>): TOptions {\r\n    return { ...(options as any) }\r\n  }\r\n  public abstract transform(context: Context): Promise<void>\r\n}\r\n", "// maybe acorn-walk would work if my types were better,\r\n// but typescript is very confusing\r\n// this code is extended upon from acorn-walk, see links and license below\r\n\r\n//! MIT License\r\n//!\r\n//! Copyright (C) 2012-2020 by various contributors (see AUTHORS)\r\n//!\r\n//! Permission is hereby granted, free of charge, to any person obtaining a copy\r\n//! of this software and associated documentation files (the \"Software\"), to deal\r\n//! in the Software without restriction, including without limitation the rights\r\n//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n//! copies of the Software, and to permit persons to whom the Software is\r\n//! furnished to do so, subject to the following conditions:\r\n//!\r\n//! The above copyright notice and this permission notice shall be included in\r\n//! all copies or substantial portions of the Software.\r\n//!\r\n//! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n//! THE SOFTWARE.\r\n//!\r\n//! ^ https://github.com/acornjs/acorn/blob/49ac049201/AUTHORS\r\n//! ^ https://github.com/acornjs/acorn/blob/49ac049201/acorn-walk/src/index.js\r\n\r\nimport { base as AcornBaseVisitors } from 'acorn-walk'\r\nimport * as ESTree from 'estree'\r\nimport { NodeType, NodeByType, Node } from './types'\r\n\r\ntype WalkerCallback<TState> = (node: ESTree.Node, state: TState) => void\r\n\r\ntype WalkerFn<T extends NodeType, TState> = (\r\n  node: NodeByType<T>,\r\n  state: TState | Node[],\r\n  ancestors: Node[]\r\n) => any\r\ntype Visitors<TState> = {\r\n  [type in NodeType]?: WalkerFn<type, TState>\r\n}\r\n\r\ntype RecursiveWalkerFn<T extends NodeType, TState> = (\r\n  node: NodeByType<T>,\r\n  state: TState | undefined,\r\n  callback: WalkerCallback<TState>\r\n) => void\r\ntype RecursiveVisitors<TState> = {\r\n  [type in NodeType]?: RecursiveWalkerFn<type, TState>\r\n}\r\n\r\nexport function walk<TState>(\r\n  node: Node,\r\n  visitors: Visitors<TState>,\r\n  base?: RecursiveVisitors<TState>,\r\n  state?: TState,\r\n  _override?: NodeType\r\n): Node {\r\n  let ancestors: Node[] = []\r\n  const baseVisitors = base || AcornBaseVisitors\r\n  ;(function c(node, st, override) {\r\n    let type: NodeType = override || node.type,\r\n      found = visitors[type]\r\n    let isNew = node !== ancestors[ancestors.length - 1]\r\n    if (isNew) ancestors.push(node)\r\n    baseVisitors[type]!(node as any, st, c as any) // this isn't undefined?\r\n    if (found) {\r\n      try {\r\n        // new node\r\n        found(node as any, st || ancestors, ancestors)\r\n      } catch (err: any) {\r\n        //throw err\r\n        console.error(\r\n          'Caught an error while attempting to run AST visitor!\\n\\nnode =',\r\n          node,\r\n          '\\nerr =',\r\n          err\r\n        )\r\n      }\r\n    }\r\n    if (isNew) ancestors.pop()\r\n  })(node, state, _override)\r\n  return node\r\n}\r\n\r\nclass Found<TNode extends Node> {\r\n  node: TNode\r\n  constructor(node: TNode) {\r\n    this.node = node\r\n  }\r\n}\r\n\r\n// For scope\r\nexport function findNodeAt<TNode extends Node>(\r\n  node: Node,\r\n  range: [number, number],\r\n  test: TNode['type'],\r\n  base?: RecursiveVisitors<{}>\r\n): TNode | undefined {\r\n  const baseVisitors = base || AcornBaseVisitors\r\n  const start = range[0],\r\n    end = range[1]\r\n  try {\r\n    ;(function c(node, _st, override) {\r\n      let type: NodeType = override || node.type\r\n      if (\r\n        (start == null || node.start <= start) &&\r\n        (end == null || node.end >= end)\r\n      )\r\n        baseVisitors[type]!(node as any, {}, c as any)\r\n      if (\r\n        (start == null || node.start === start) &&\r\n        (end == null || node.end === end) &&\r\n        node.type === test\r\n      ) {\r\n        throw new Found<TNode>(node as TNode)\r\n      }\r\n    })(node)\r\n  } catch (ex) {\r\n    if (ex instanceof Found) return ex.node as TNode\r\n    throw ex\r\n  }\r\n}\r\n", "import { Node as ENode } from 'estree'\r\nimport {\r\n  Expression,\r\n  Node as SNode,\r\n  Literal,\r\n  BooleanLiteral,\r\n  NumericLiteral,\r\n  StringLiteral,\r\n  UnaryExpression,\r\n  NumericUnaryExpression,\r\n  Statement,\r\n  ExpressionStatement,\r\n  SequenceExpression,\r\n  AssignmentExpression,\r\n  ReturnStatement,\r\n  VariableDeclaration,\r\n  ArrayExpression,\r\n  Pattern,\r\n  Identifier,\r\n  FunctionExpression,\r\n  BlockStatement,\r\n  PrivateIdentifier,\r\n  Super,\r\n  BinaryExpression,\r\n  CallExpression,\r\n  MemberExpression,\r\n  IfStatement,\r\n  ObjectExpression,\r\n  SwitchStatement,\r\n  UpdateExpression,\r\n  FunctionDeclaration,\r\n  ArrowFunctionExpression,\r\n  ForStatement,\r\n  LogicalExpression,\r\n} from './types'\r\n\r\ntype Node = ENode | SNode\r\n\r\nexport function isPrivateIdentifier(node: Node): node is PrivateIdentifier {\r\n  return node.type === 'PrivateIdentifier'\r\n}\r\n\r\nexport function isLiteral(node: Node): node is Literal {\r\n  return node.type === 'Literal'\r\n}\r\nexport function isLiteralString(node: Node): node is StringLiteral {\r\n  return isLiteral(node) && typeof node.value === 'string'\r\n}\r\n\r\nexport function isLiteralNumeric(node: Node): node is NumericLiteral {\r\n  return isLiteral(node) && typeof node.value === 'number'\r\n}\r\n\r\nexport function isLiteralBoolean(node: Node): node is BooleanLiteral {\r\n  return isLiteral(node) && typeof node.value === 'boolean'\r\n}\r\n\r\nexport function isUnaryExpression(node: Node): node is UnaryExpression {\r\n  return node.type === 'UnaryExpression'\r\n}\r\n\r\nexport function isUnaryExpressionNumeric(\r\n  node: Node\r\n): node is NumericUnaryExpression {\r\n  return isUnaryExpression(node) && isLiteralNumeric(node.argument)\r\n}\r\n\r\nexport function isExpressionStatement(node: Node): node is ExpressionStatement {\r\n  return node.type === 'ExpressionStatement'\r\n}\r\n\r\nexport function isSequenceExpression(node: Node): node is SequenceExpression {\r\n  return node.type === 'SequenceExpression'\r\n}\r\n\r\nexport function isAssignmentExpression(\r\n  node: Node\r\n): node is AssignmentExpression {\r\n  return node.type === 'AssignmentExpression'\r\n}\r\n\r\nexport function isReturnStatement(node: Node): node is ReturnStatement {\r\n  return node.type === 'ReturnStatement'\r\n}\r\n\r\nexport function isVariableDeclaration(node: Node): node is VariableDeclaration {\r\n  return node.type === 'VariableDeclaration'\r\n}\r\n\r\nexport function isArrayExpression(node: Node): node is ArrayExpression {\r\n  return node.type === 'ArrayExpression'\r\n}\r\n\r\nexport function isIdentifier(node: Node): node is Identifier {\r\n  return node.type === 'Identifier'\r\n}\r\n\r\nexport function isArrowFunctionExpression(\r\n  node: Node\r\n): node is ArrowFunctionExpression {\r\n  return node.type === 'ArrowFunctionExpression'\r\n}\r\n\r\nexport function isFunctionExpression(node: Node): node is FunctionExpression {\r\n  return node.type === 'FunctionExpression'\r\n}\r\n\r\nexport function isFunctionDeclaration(node: Node): node is FunctionDeclaration {\r\n  return node.type === 'FunctionDeclaration'\r\n}\r\n\r\nexport function isUpdateExpression(node: Node): node is UpdateExpression {\r\n  return node.type === 'UpdateExpression'\r\n}\r\n\r\nexport function isCallExpression(node: Node): node is CallExpression {\r\n  return node.type === 'CallExpression'\r\n}\r\n\r\nexport function isBlockStatement(node: Node): node is BlockStatement {\r\n  return node.type === 'BlockStatement'\r\n}\r\n\r\nexport function isSwitchStatement(node: Node): node is SwitchStatement {\r\n  return node.type === 'SwitchStatement'\r\n}\r\n\r\nexport function isBinaryExpression(node: Node): node is BinaryExpression {\r\n  return node.type === 'BinaryExpression'\r\n}\r\n\r\nexport function isMemberExpression(node: Node): node is MemberExpression {\r\n  return node.type === 'MemberExpression'\r\n}\r\n\r\nexport function isIfStatement(node: Node): node is IfStatement {\r\n  return node.type === 'IfStatement'\r\n}\r\n\r\nexport function isForStatement(node: Node): node is ForStatement {\r\n  return node.type === 'ForStatement'\r\n}\r\n\r\nexport function isObjectExpresesion(node: Node): node is ObjectExpression {\r\n  return node.type === 'ObjectExpression'\r\n}\r\n\r\nexport function isLogicalExpression(node: Node): node is LogicalExpression {\r\n  return node.type === 'LogicalExpression'\r\n}\r\n", "import { isLiteral, isIdentifier } from './guard'\r\nimport { Node, EmptyStatement, Literal, Identifier } from './types'\r\n\r\n// Immutability\u2122\u2122\u2122\u2122\u2122\u2122\r\nexport function immutate(item: any) {\r\n  return JSON.parse(JSON.stringify(item))\r\n}\r\n\r\nexport function literalOrIdentifierToString(node: Node): string {\r\n  if (!isLiteral(node) && !isIdentifier(node))\r\n    throw new TypeError('Node is not Literal or Identifier')\r\n  return isLiteral(node) ? node.value!.toString() : node.name\r\n}\r\n\r\nexport function filterEmptyStatements(nodes: Node[]): Node[] {\r\n  return nodes.filter((i) => i.type !== 'EmptyStatement')\r\n}\r\n", "import {\r\n  Node,\r\n  Literal,\r\n  Property,\r\n  sp,\r\n  getBlockId,\r\n  PropertyLiteral,\r\n  CallExpression,\r\n  FunctionExpression,\r\n  Identifier,\r\n  ObjectExpression,\r\n  Statement,\r\n} from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { walk } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\nimport Context from '../context'\r\nimport {\r\n  immutate,\r\n  literalOrIdentifierToString,\r\n  filterEmptyStatements,\r\n} from '../util/helpers'\r\n\r\nexport interface ControlFlowOptions extends TransformerOptions {}\r\nexport default class ControlFlow extends Transformer<ControlFlowOptions> {\r\n  constructor(options: Partial<ControlFlowOptions>) {\r\n    super('ControlFlow', options)\r\n  }\r\n\r\n  // maybe global util function\r\n  private translateCallExp(fx: FunctionExpression, cx: CallExpression) {\r\n    if (!Guard.isReturnStatement(fx.body.body[0]))\r\n      throw new TypeError(\r\n        'Function in CFSN was invalid (not a returnstatement)'\r\n      )\r\n    if (!fx.params.every((p) => Guard.isIdentifier(p)))\r\n      throw new TypeError('Function in CFSN was invalid (not ident params)')\r\n    if (!fx.body.body[0].argument)\r\n      throw new TypeError('Function in CFSN was invalid (void return)')\r\n\r\n    let params = fx.params as Identifier[],\r\n      paramMap: { [ident: string]: Node } = {}\r\n    let i = 0\r\n    for (const p of params) {\r\n      paramMap[p.name] = cx.arguments[i]\r\n      ++i\r\n    }\r\n    let immRtn = immutate(fx.body.body[0].argument)\r\n    walk(immRtn, {\r\n      Identifier(id) {\r\n        if (!paramMap[id.name]) return\r\n        sp<Node>(id, paramMap[id.name])\r\n      },\r\n    })\r\n\r\n    return immRtn as Node\r\n  }\r\n\r\n  // fixes empty object inits where there are setters in the same block\r\n  populateEmptyObjects(context: Context) {\r\n    walk(context.ast, {\r\n      BlockStatement(node) {\r\n        // find empty object decls\r\n        walk(node, {\r\n          VariableDeclarator(decl) {\r\n            if (!Guard.isIdentifier(decl.id)) return\r\n            if (!decl.init || !Guard.isObjectExpresesion(decl.init)) return\r\n\r\n            if (decl.init.properties.length !== 0) return\r\n\r\n            const objName = decl.id.name\r\n            // now find the setters\r\n\r\n            // TODO: this will break if the value is set with a value set\r\n            // after the Object is defined\r\n            walk(node, {\r\n              ExpressionStatement(expr) {\r\n                if (!Guard.isAssignmentExpression(expr.expression)) return\r\n                let ae = expr.expression\r\n\r\n                if (!Guard.isMemberExpression(ae.left)) return\r\n\r\n                if (\r\n                  !Guard.isIdentifier(ae.left.object) ||\r\n                  !Guard.isIdentifier(ae.left.property)\r\n                )\r\n                  return\r\n\r\n                if (ae.left.object.name !== objName) return\r\n\r\n                let prop: Property = {\r\n                  type: 'Property',\r\n                  start: 0,\r\n                  end: 0,\r\n                  method: false,\r\n                  shorthand: false,\r\n                  computed: false,\r\n                  key: ae.left.property,\r\n                  value: ae.right,\r\n                  kind: 'init',\r\n                }\r\n                ;(decl.init as ObjectExpression).properties.push(prop)\r\n\r\n                // remove the ExpressionStatement\r\n                ;(expr as any).type = 'EmptyStatement'\r\n\r\n                context.log(\r\n                  `${objName}.${ae.left.property.name} = ${ae.right.type}`\r\n                )\r\n              },\r\n            })\r\n          },\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // separate finding literals/functions from each other?\r\n  // current way makes code a bit confusing to follow ^^\r\n  findStorageNode(context: Context) {\r\n    const { findStorageNodeAliases } = this\r\n    walk(context.ast, {\r\n      BlockStatement(node) {\r\n        // /shrug\r\n        let bid = getBlockId(node)\r\n\r\n        if (context.controlFlowStorageNodes[bid]) return\r\n        if (node.body.length === 0) return\r\n\r\n        walk(node, {\r\n          VariableDeclaration(vd) {\r\n            let rm: string[] = []\r\n            for (const decl of vd.declarations) {\r\n              if (!Guard.isIdentifier(decl.id)) continue\r\n              if (decl.init?.type !== 'ObjectExpression') continue\r\n              if (decl.init.properties.length === 0) continue\r\n              if (\r\n                !decl.init.properties.every(\r\n                  (p) =>\r\n                    p.type !== 'SpreadElement' &&\r\n                    ['FunctionExpression', 'Literal'].includes(p.value.type) &&\r\n                    (p.key.type === 'Literal' || p.key.type === 'Identifier') &&\r\n                    literalOrIdentifierToString((p as any).key).length === 5\r\n                )\r\n              )\r\n                continue\r\n              context.controlFlowStorageNodes[bid] = {\r\n                identifier: decl.id.name,\r\n                aliases: [decl.id.name],\r\n                functions: [],\r\n                literals: [],\r\n              }\r\n              const cfsn = context.controlFlowStorageNodes[bid]\r\n              for (const prop of decl.init.properties as PropertyLiteral[]) {\r\n                let kn: Identifier | Literal = prop.key\r\n                let key = (\r\n                    Guard.isIdentifier(kn) ? kn.name : kn.value\r\n                  )! as string,\r\n                  i = -1\r\n                if (Guard.isLiteral(prop.value)) {\r\n                  if (\r\n                    (i = cfsn.literals.findIndex(\r\n                      (l) => l.identifier === key\r\n                    )) !== -1\r\n                  ) {\r\n                    // exists\r\n                    cfsn.literals[i].value = prop.value.value as string\r\n                  } else {\r\n                    cfsn.literals.push({\r\n                      identifier: key,\r\n                      value: prop.value.value as string,\r\n                    })\r\n                  }\r\n                } else if (Guard.isFunctionExpression(prop.value)) {\r\n                  let fnb = filterEmptyStatements(prop.value.body.body)\r\n                  if (fnb.length !== 1) continue\r\n                  if (!Guard.isReturnStatement(fnb[0])) continue\r\n                  let imm = immutate(prop.value)\r\n                  imm.body.body = fnb\r\n                  if (\r\n                    (i = cfsn.functions.findIndex(\r\n                      (f) => f.identifier === key\r\n                    )) !== -1\r\n                  ) {\r\n                    // exists\r\n                    cfsn.functions[i].node = imm\r\n                  } else {\r\n                    cfsn.functions.push({\r\n                      identifier: key,\r\n                      node: imm,\r\n                    })\r\n                  }\r\n                }\r\n              }\r\n              context.log(\r\n                'Found control flow node id =',\r\n                decl.id.name,\r\n                '#fn =',\r\n                cfsn.functions.length,\r\n                '#lit =',\r\n                cfsn.literals.length\r\n              )\r\n              if (context.removeGarbage) {\r\n                rm.push(`${decl.start}!${decl.end}`)\r\n              }\r\n            }\r\n\r\n            // the declaration should probably be removed only after the usages\r\n            // are replaced, so there is no dep on each key being 5chars\r\n            // or walk the node for Identifier usages and check parent is not\r\n            // a CallExpr or MembExpr\r\n            vd.declarations = vd.declarations.filter(\r\n              (d) => !rm.includes(`${d.start}!${d.end}`)\r\n            )\r\n            if (vd.declarations.length === 0) {\r\n              // this node wont generate if it has no declarations left\r\n              ;(vd as any).type = 'EmptyStatement'\r\n            }\r\n\r\n            findStorageNodeAliases(context, node).replacer(context, node)\r\n          },\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  findStorageNodeAliases = (context: Context, ast: Node) => {\r\n    walk(ast, {\r\n      BlockStatement(node) {\r\n        let bid = getBlockId(node)\r\n\r\n        if (!context.controlFlowStorageNodes[bid]) return\r\n        if (node.body.length === 0) return\r\n        const cfsn = context.controlFlowStorageNodes[bid]\r\n\r\n        walk(node, {\r\n          VariableDeclaration(vd) {\r\n            let rm: string[] = []\r\n            for (const decl of vd.declarations) {\r\n              if (\r\n                !decl.init ||\r\n                !Guard.isIdentifier(decl.id) ||\r\n                !Guard.isIdentifier(decl.init)\r\n              )\r\n                continue\r\n              if (cfsn.aliases.includes(decl.init.name)) {\r\n                cfsn.aliases.push(decl.id.name)\r\n                rm.push(`${decl.start}!${decl.end}`)\r\n              }\r\n            }\r\n\r\n            vd.declarations = vd.declarations.filter(\r\n              (d) => !rm.includes(`${d.start}!${d.end}`)\r\n            )\r\n            if (vd.declarations.length === 0) {\r\n              // this node wont generate if it has no declarations left\r\n              ;(vd as any).type = 'EmptyStatement'\r\n            }\r\n          },\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  replacer = (context: Context, ast: Node) => {\r\n    const { translateCallExp } = this\r\n    walk(ast, {\r\n      BlockStatement(node) {\r\n        const bid = getBlockId(node)\r\n        if (!context.controlFlowStorageNodes[bid]) return\r\n        const cfsn = context.controlFlowStorageNodes[bid]\r\n\r\n        walk(node, {\r\n          MemberExpression(mx) {\r\n            if (!Guard.isIdentifier(mx.object)) return\r\n            if (!Guard.isIdentifier(mx.property)) return\r\n            if (!cfsn.aliases.includes(mx.object.name)) return\r\n\r\n            // typeguards still dont work inside arrow funcs(((((\r\n            let ident = mx.property.name,\r\n              i = -1\r\n\r\n            if (\r\n              (i = cfsn.literals.findIndex((l) => l.identifier === ident)) !==\r\n              -1\r\n            ) {\r\n              // ident is a literal\r\n              sp<Literal>(mx, {\r\n                type: 'Literal',\r\n                value: cfsn.literals[i].value,\r\n              })\r\n            }\r\n          },\r\n          CallExpression(cx) {\r\n            if (!Guard.isMemberExpression(cx.callee)) return\r\n            if (!Guard.isIdentifier(cx.callee.object)) return\r\n            if (!Guard.isIdentifier(cx.callee.property)) return\r\n            if (!cfsn.aliases.includes(cx.callee.object.name)) return\r\n\r\n            let ident = cx.callee.property.name,\r\n              i = -1\r\n\r\n            if (\r\n              (i = cfsn.functions.findIndex((f) => f.identifier === ident)) !==\r\n              -1\r\n            ) {\r\n              // ident is a function\r\n              const fx = cfsn.functions[i].node\r\n              sp<Node>(cx, translateCallExp(fx, cx))\r\n            }\r\n          },\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  deflatten(context: Context) {\r\n    walk(context.ast, {\r\n      WhileStatement(node, _, ancestors) {\r\n        if (!Guard.isLiteralBoolean(node.test) || node.test.value !== true)\r\n          return\r\n        if (\r\n          !Guard.isBlockStatement(node.body) ||\r\n          node.body.body.length === 0 ||\r\n          !Guard.isSwitchStatement(node.body.body[0])\r\n        )\r\n          return\r\n\r\n        const parent = ancestors[ancestors.length - 2]\r\n        if (!Guard.isBlockStatement(parent)) return\r\n\r\n        const switchStmt = node.body.body[0]\r\n\r\n        if (!Guard.isMemberExpression(switchStmt.discriminant)) return\r\n        if (\r\n          !Guard.isIdentifier(switchStmt.discriminant.object) ||\r\n          !Guard.isUpdateExpression(switchStmt.discriminant.property) ||\r\n          switchStmt.discriminant.property.operator !== '++' ||\r\n          switchStmt.discriminant.property.prefix !== false || // prefix ++s change \"return\" of updexp\r\n          !Guard.isIdentifier(switchStmt.discriminant.property.argument)\r\n        )\r\n          return\r\n\r\n        let shuffleId = switchStmt.discriminant.object.name,\r\n          indexId = switchStmt.discriminant.property.argument.name\r\n        let shuffleArr: string[] = [],\r\n          startIdx = -1\r\n\r\n        walk(parent, {\r\n          VariableDeclaration(vd) {\r\n            let rm: string[] = []\r\n            for (const decl of vd.declarations) {\r\n              if (!Guard.isIdentifier(decl.id)) continue\r\n              if (!decl.init) continue\r\n              if (decl.id.name === shuffleId) {\r\n                if (!Guard.isCallExpression(decl.init)) continue\r\n                if (!Guard.isMemberExpression(decl.init.callee)) continue\r\n                if (!Guard.isLiteralString(decl.init.callee.object)) continue\r\n                if (\r\n                  !Guard.isIdentifier(decl.init.callee.property) ||\r\n                  decl.init.callee.property.name !== 'split'\r\n                )\r\n                  continue\r\n                if (!Guard.isLiteralString(decl.init.arguments[0])) continue\r\n                // 'nXnXnXnXn'.split(X)\r\n                let shfStr = decl.init.callee.object.value,\r\n                  sep = decl.init.arguments[0].value\r\n                shuffleArr = shfStr.split(sep)\r\n                rm.push(`${decl.start}!${decl.end}`)\r\n              } else if (decl.id.name === indexId) {\r\n                if (!Guard.isLiteralNumeric(decl.init)) continue\r\n                startIdx = decl.init.value\r\n                rm.push(`${decl.start}!${decl.end}`)\r\n              } else {\r\n                continue\r\n              }\r\n            }\r\n\r\n            vd.declarations = vd.declarations.filter(\r\n              (d) => !rm.includes(`${d.start}!${d.end}`)\r\n            )\r\n            if (vd.declarations.length === 0) {\r\n              ;(vd as any).type = 'EmptyStatement'\r\n            }\r\n          },\r\n        })\r\n\r\n        // didnt locate arr or index\r\n        if (shuffleArr.length === 0 || startIdx === -1) return\r\n\r\n        let nodes: Statement[][] = []\r\n\r\n        for (let i = startIdx; i < shuffleArr.length; i++) {\r\n          let caseNum = shuffleArr[i]\r\n          let caze = switchStmt.cases.find(\r\n            (c) => c.test && Guard.isLiteral(c.test) && c.test.value === caseNum\r\n          )\r\n          if (!caze) return // should restore the variables above before returning\r\n          nodes.push(\r\n            caze.consequent.filter((i) => i.type !== 'ContinueStatement')\r\n          )\r\n        }\r\n\r\n        let ourIdx = parent.body.findIndex(\r\n          (e) =>\r\n            e.type === node.type && e.start === node.start && e.end === node.end\r\n        )\r\n        parent.body.splice(ourIdx, 1, ...nodes.flat())\r\n\r\n        context.log(\r\n          'Found flattened control flow arr =',\r\n          shuffleArr,\r\n          'idx =',\r\n          startIdx\r\n        )\r\n      },\r\n    })\r\n\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.populateEmptyObjects(context)\r\n      .findStorageNode(context)\r\n      .deflatten(context)\r\n  }\r\n}\r\n", "import { Program, BlockStatement, sp } from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { walk } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\nimport Context from '../context'\r\n\r\nexport interface DesqeuenceOptions extends TransformerOptions {}\r\nexport default class Desequence extends Transformer<DesqeuenceOptions> {\r\n  constructor(options: Partial<DesqeuenceOptions>) {\r\n    super('Desequence', options)\r\n  }\r\n\r\n  desequence(ast: Program) {\r\n    function visitor(node: BlockStatement | Program) {\r\n      // find expstmt > seqexp in node.body\r\n\r\n      for (let stmt of node.body) {\r\n        if (\r\n          Guard.isExpressionStatement(stmt) &&\r\n          Guard.isSequenceExpression(stmt.expression)\r\n        ) {\r\n          let i = node.body.findIndex(\r\n            (s) => s.start === stmt.start && s.end === stmt.end\r\n          )\r\n          let expr = stmt.expression.expressions.map((exp) => ({\r\n            type: 'ExpressionStatement',\r\n            expression: exp,\r\n          }))\r\n          ;(node.body[i] as any) = expr\r\n        }\r\n      }\r\n      sp<Program>(node, { body: node.body.flat() })\r\n    }\r\n    walk(ast, {\r\n      BlockStatement(node) {\r\n        visitor(node)\r\n      },\r\n      Program(node) {\r\n        visitor(node)\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.desequence(context.ast)\r\n  }\r\n}\r\n", "import {\r\n  sp,\r\n  Property,\r\n  Literal,\r\n  Function,\r\n  ArrowFunctionExpression,\r\n  FunctionExpression,\r\n  FunctionDeclaration,\r\n  Identifier,\r\n  VariableDeclarator,\r\n  VariableDeclaration,\r\n} from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { walk, findNodeAt } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\nimport Context from '../context'\r\n\r\nexport interface LiteralMapOptions extends TransformerOptions {}\r\nexport default class LiteralMap extends Transformer<LiteralMapOptions> {\r\n  constructor(options: Partial<LiteralMapOptions>) {\r\n    super('LiteralMap', options)\r\n  }\r\n\r\n  demap(context: Context) {\r\n    walk(context.ast, {\r\n      BlockStatement(node) {\r\n        const map: { [x: string]: { [x: string]: any } } = {}\r\n\r\n        walk(node, {\r\n          VariableDeclaration(vd) {\r\n            let rm: string[] = []\r\n            for (const decl of vd.declarations) {\r\n              if (\r\n                !decl.init ||\r\n                decl.init.type !== 'ObjectExpression' ||\r\n                !Guard.isIdentifier(decl.id)\r\n              )\r\n                continue\r\n              if (decl.init.properties.length === 0) continue\r\n              if (\r\n                !decl.init.properties.every(\r\n                  (p) =>\r\n                    p.type !== 'SpreadElement' &&\r\n                    (Guard.isLiteral(p.key) || Guard.isIdentifier(p.key)) &&\r\n                    Guard.isLiteral(p.value)\r\n                )\r\n              )\r\n                continue\r\n\r\n              const name = decl.id.name\r\n              map[name] = map[name] || {}\r\n\r\n              for (const _prop of decl.init.properties) {\r\n                const prop = _prop as Property\r\n                let key =\r\n                  prop.key.type === 'Identifier'\r\n                    ? prop.key.name\r\n                    : ((prop.key as Literal).value as string)\r\n                map[name][key] = (prop.value as Literal).value as string\r\n              }\r\n\r\n              if (context.removeGarbage) {\r\n                rm.push(`${decl.start}!${decl.end}`)\r\n              }\r\n            }\r\n            vd.declarations = vd.declarations.filter(\r\n              (d) => !rm.includes(`${d.start}!${d.end}`)\r\n            )\r\n          },\r\n        })\r\n\r\n        walk(node, {\r\n          MemberExpression(exp) {\r\n            if (\r\n              !Guard.isIdentifier(exp.object) ||\r\n              (!Guard.isLiteral(exp.property) &&\r\n                !Guard.isIdentifier(exp.property))\r\n            )\r\n              return\r\n            let mapObj = map[exp.object.name]\r\n            if (!mapObj) return\r\n\r\n            let key = Guard.isIdentifier(exp.property)\r\n              ? exp.property.name\r\n              : ((exp.property as Literal).value as string)\r\n            let val = mapObj[key]\r\n            if (typeof val === 'undefined') return // ! check causes !0 == true.\r\n            sp<Literal>(exp, {\r\n              type: 'Literal',\r\n              value: val,\r\n            })\r\n          },\r\n        })\r\n      },\r\n    })\r\n\r\n    return this\r\n  }\r\n\r\n  // replace read-only variables in functions\r\n  literals(context: Context) {\r\n    function visitor(func: Function) {\r\n      const scope = context.scopeManager.acquire(func)\r\n      if (!scope) return\r\n\r\n      for (const v of scope.variables) {\r\n        if (/*func.start === 3547 && */ v.name === 'q') debugger\r\n        if (v.name === 'arguments') continue\r\n        if (v.identifiers.length !== 1) continue // ?\r\n        if (v.defs.length !== 1) continue // ?\r\n\r\n        const def = v.defs[0]\r\n        if (def.type !== 'Variable') continue // ?\r\n        const vd = def.node as VariableDeclarator\r\n\r\n        if (vd.init?.type !== 'Literal') continue\r\n        if (typeof vd.init.value === 'string' && vd.init.value.length === 65)\r\n          continue\r\n\r\n        // prevents us from replacing overwrote variables\r\n        if (!v.references.every((ref) => ref.init || ref.isReadOnly())) continue\r\n\r\n        for (const ref of v.references) {\r\n          // Dont replace our init reference lol\r\n          if (ref.init) {\r\n            let node = def.node as VariableDeclarator\r\n            let p = def.parent as VariableDeclaration\r\n            if (p.type === 'VariableDeclaration') {\r\n              p.declarations = p.declarations.filter(\r\n                (decl) => decl.start !== node.start && decl.end !== node.end\r\n              )\r\n            }\r\n            continue\r\n          }\r\n          const refid = findNodeAt<Identifier>(\r\n            func,\r\n            ref.identifier.range!,\r\n            'Identifier'\r\n          )\r\n          if (!refid) continue // hm\r\n          sp<Literal>(refid, vd.init)\r\n        }\r\n      }\r\n    }\r\n    walk(context.ast, {\r\n      FunctionDeclaration: visitor,\r\n      FunctionExpression: visitor,\r\n      ArrowFunctionExpression: visitor,\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.demap(context).literals(context)\r\n  }\r\n}\r\n", "import { Program, Identifier, sp } from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { walk } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\nimport Context from '../context'\r\n\r\n// only replace if the property accessor matches this\r\n// will not match content-type\r\nconst VALID_DOT_REGEX = /^[a-z][\\w]*$/i\r\n\r\nexport interface MemberExpressionCleanerOptions extends TransformerOptions {}\r\nexport default class MemberExpressionCleaner extends Transformer<MemberExpressionCleanerOptions> {\r\n  constructor(options: Partial<MemberExpressionCleanerOptions>) {\r\n    super('MemberExpressionCleaner', options)\r\n  }\r\n\r\n  clean(ast: Program) {\r\n    walk(ast, {\r\n      MemberExpression(node) {\r\n        if (\r\n          //!Guard.isIdentifier(node.object) ||\r\n          Guard.isPrivateIdentifier(node.property) ||\r\n          !Guard.isLiteralString(node.property)\r\n        )\r\n          return\r\n\r\n        if (!node.property.value.match(VALID_DOT_REGEX)) return\r\n\r\n        node.computed = false\r\n        sp<Identifier>(node.property, {\r\n          type: 'Identifier',\r\n          name: node.property.value,\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.clean(context.ast)\r\n  }\r\n}\r\n", "import {\r\n  UnaryExpression,\r\n  Literal,\r\n  NumericLiteral,\r\n  NumericUnaryExpression,\r\n} from './types'\r\nimport * as Guard from './guard'\r\n\r\nexport function unaryExpressionToNumber(\r\n  node: UnaryExpression,\r\n  pi: boolean = false\r\n): number {\r\n  if (node.argument.type !== 'Literal')\r\n    throw new TypeError('UnaryExpression argument is not Literal')\r\n  if (typeof node.argument.value !== 'number' && !pi)\r\n    throw new TypeError('UnaryExpression argument value is not number')\r\n\r\n  let num = pi\r\n    ? parseInt(node.argument.value as string)\r\n    : (node.argument.value as number)\r\n  if (node.operator === '-') num = num * -1\r\n  return num\r\n}\r\n\r\nexport function literalOrUnaryExpressionToNumber(\r\n  node: Literal | UnaryExpression,\r\n  pi: boolean = false\r\n): number {\r\n  if (Guard.isLiteralNumeric(node)) {\r\n    return node.value\r\n  } else if (Guard.isLiteralString(node) && pi) {\r\n    return parseInt(node.value)\r\n  } else if (Guard.isUnaryExpression(node)) {\r\n    return unaryExpressionToNumber(node, pi)\r\n  }\r\n  throw new TypeError(\"Couldn't translate node to Number\")\r\n}\r\n\r\nexport function createLiteral(\r\n  value: number\r\n): NumericLiteral | NumericUnaryExpression {\r\n  return value < 0\r\n    ? ({\r\n        type: 'UnaryExpression',\r\n        prefix: true,\r\n        operator: '-',\r\n        argument: {\r\n          type: 'Literal',\r\n          start: 0,\r\n          end: 0,\r\n          value: Math.abs(value),\r\n        },\r\n      } as NumericUnaryExpression)\r\n    : ({\r\n        type: 'Literal',\r\n        value,\r\n      } as NumericLiteral)\r\n}\r\n", "import { BinaryOperator } from './types'\r\n\r\nexport function mathEval(\r\n  lhs: number,\r\n  operator: BinaryOperator,\r\n  rhs: number\r\n): number {\r\n  switch (operator) {\r\n    case '+':\r\n      return lhs + rhs\r\n    case '*':\r\n      return lhs * rhs\r\n    case '-':\r\n      return lhs - rhs\r\n    case '/':\r\n      return lhs / rhs\r\n    default:\r\n      return lhs\r\n  }\r\n}\r\n", "import {\r\n  NumericLiteral,\r\n  Literal,\r\n  sp,\r\n  NumericUnaryExpression,\r\n  BinaryOperator,\r\n  Node,\r\n  Identifier,\r\n  BlockStatement,\r\n  IfStatement,\r\n  Statement,\r\n  Function,\r\n  CallExpression,\r\n} from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { walk } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\n\r\nimport { unaryExpressionToNumber, createLiteral } from '../util/translator'\r\nimport { mathEval } from '../util/math'\r\n\r\nimport Context from '../context'\r\nimport { immutate } from '../util/helpers'\r\n\r\nexport interface SimplifyOptions extends TransformerOptions {}\r\nexport default class Simplify extends Transformer<SimplifyOptions> {\r\n  constructor(options: Partial<SimplifyOptions>) {\r\n    super('Simplify', options)\r\n  }\r\n\r\n  // incase other opers like shft/xor are found in code\r\n  private ALLOWED_MATH_OPERS = ['+', '-', '*', '/']\r\n\r\n  private ALLOWED_COMPARISON_OPERS = [\r\n    '==',\r\n    '===',\r\n    '!=',\r\n    '!==',\r\n    '>',\r\n    '<',\r\n    '<=',\r\n    '>=',\r\n  ]\r\n\r\n  negativeString(context: Context) {\r\n    walk(context.ast, {\r\n      UnaryExpression(node) {\r\n        if (\r\n          node.argument.type === 'Literal' &&\r\n          typeof node.argument.value === 'string' &&\r\n          node.argument.value.startsWith('0x') &&\r\n          node.operator === '-'\r\n        ) {\r\n          sp<Literal>(node, {\r\n            type: 'Literal',\r\n            value: unaryExpressionToNumber(node, true),\r\n          })\r\n        }\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // TODO: global method > helpers.ts\r\n  binEval(\r\n    lhs: string | number,\r\n    operator: BinaryOperator,\r\n    rhs: string | number\r\n  ): boolean {\r\n    switch (operator) {\r\n      case '==':\r\n        return lhs == rhs\r\n      case '===':\r\n        return lhs === rhs\r\n      case '!=':\r\n        return lhs != rhs\r\n      case '!==':\r\n        return lhs !== rhs\r\n      case '>':\r\n        return lhs > rhs\r\n      case '<':\r\n        return lhs < rhs\r\n      case '<=':\r\n        return lhs <= rhs\r\n      case '>=':\r\n        return lhs >= rhs\r\n    }\r\n    throw new TypeError(`Operator ${operator} is invalid`)\r\n  }\r\n\r\n  stringConcat(context: Context) {\r\n    walk(context.ast, {\r\n      BinaryExpression(node) {\r\n        if (\r\n          Guard.isLiteralString(node.left) &&\r\n          Guard.isLiteralString(node.right) &&\r\n          node.operator === '+'\r\n        ) {\r\n          sp<Literal>(node, {\r\n            type: 'Literal',\r\n            value: node.left.value + node.right.value,\r\n          })\r\n        }\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // This is used in stringdecoder for the push/shift iife\r\n  math(_node: Node) {\r\n    const { ALLOWED_MATH_OPERS } = this\r\n    walk(_node, {\r\n      BinaryExpression(node) {\r\n        // unex & number\r\n        if (!ALLOWED_MATH_OPERS.includes(node.operator)) return\r\n        if (Guard.isUnaryExpressionNumeric(node.left)) {\r\n          sp<NumericLiteral>(node.left, {\r\n            type: 'Literal',\r\n            value: unaryExpressionToNumber(node.left),\r\n          })\r\n        }\r\n\r\n        if (Guard.isUnaryExpressionNumeric(node.right)) {\r\n          sp<NumericLiteral>(node.right, {\r\n            type: 'Literal',\r\n            value: unaryExpressionToNumber(node.right),\r\n          })\r\n        }\r\n\r\n        if (\r\n          Guard.isLiteralNumeric(node.left) &&\r\n          Guard.isLiteralNumeric(node.right)\r\n        ) {\r\n          const val = mathEval(node.left.value, node.operator, node.right.value)\r\n          if (isNaN(val)) {\r\n            // will throw error on codegen, ignore\r\n            return\r\n          }\r\n          sp<any>(node, createLiteral(val))\r\n          /*sp<NumericLiteral>(node, {\r\n            type: 'Literal',\r\n            value: val,\r\n          })*/\r\n        }\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // !0/true, !1/false\r\n  // ![]/false\r\n  truthyFalsy(context: Context) {\r\n    walk(context.ast, {\r\n      UnaryExpression(node) {\r\n        if (node.operator !== '!') return\r\n        if (!Guard.isArrayExpression(node.argument)) return\r\n        if (node.argument.elements.length !== 0) return\r\n\r\n        sp<Literal>(node, {\r\n          type: 'Literal',\r\n          value: false,\r\n        })\r\n      },\r\n    })\r\n\r\n    walk(context.ast, {\r\n      UnaryExpression(node) {\r\n        if (node.operator !== '!') return\r\n        if (Guard.isLiteralBoolean(node.argument)) {\r\n          return sp<Literal>(node, {\r\n            type: 'Literal',\r\n            value: !node.argument.value,\r\n          })\r\n        } else if (Guard.isLiteralNumeric(node.argument)) {\r\n          if (![0, 1].includes(node.argument.value)) return\r\n          sp<Literal>(node, {\r\n            type: 'Literal',\r\n            value: !node.argument.value,\r\n          })\r\n        }\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  literalComparison(_node: Node) {\r\n    const { ALLOWED_COMPARISON_OPERS, binEval } = this\r\n    walk(_node, {\r\n      BinaryExpression(node) {\r\n        if (\r\n          !Guard.isLiteralNumeric(node.left) &&\r\n          !Guard.isUnaryExpressionNumeric(node.left) &&\r\n          !Guard.isLiteralString(node.left)\r\n        )\r\n          return\r\n\r\n        if (\r\n          !Guard.isLiteralNumeric(node.right) &&\r\n          !Guard.isUnaryExpressionNumeric(node.right) &&\r\n          !Guard.isLiteralString(node.right)\r\n        )\r\n          return\r\n\r\n        if (!ALLOWED_COMPARISON_OPERS.includes(node.operator)) return\r\n\r\n        let lhs = Guard.isLiteral(node.left)\r\n            ? node.left.value\r\n            : unaryExpressionToNumber(node.left),\r\n          rhs = Guard.isLiteral(node.right)\r\n            ? node.right.value\r\n            : unaryExpressionToNumber(node.right)\r\n\r\n        let res = binEval(lhs, node.operator, rhs)\r\n        sp<Literal>(node, {\r\n          type: 'Literal',\r\n          value: res,\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  singleToBlock(context: Context) {\r\n    walk(context.ast, {\r\n      ForStatement(node) {\r\n        if (Guard.isBlockStatement(node.body)) return\r\n        sp<BlockStatement>(node.body, {\r\n          type: 'BlockStatement',\r\n          body: [immutate(node.body)],\r\n        })\r\n      },\r\n      WhileStatement(node) {\r\n        if (Guard.isBlockStatement(node.body)) return\r\n        sp<BlockStatement>(node.body, {\r\n          type: 'BlockStatement',\r\n          body: [immutate(node.body)],\r\n        })\r\n      },\r\n      IfStatement(node) {\r\n        if (!Guard.isBlockStatement(node.consequent)) {\r\n          sp<BlockStatement>(node.consequent, {\r\n            type: 'BlockStatement',\r\n            body: [immutate(node.consequent)],\r\n          })\r\n        }\r\n        if (node.alternate && !Guard.isBlockStatement(node.alternate)) {\r\n          sp<BlockStatement>(node.alternate, {\r\n            type: 'BlockStatement',\r\n            body: [immutate(node.alternate)],\r\n          })\r\n        }\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  conditionalExpression(_node: Node) {\r\n    walk(_node, {\r\n      ConditionalExpression(node, _, ancestors) {\r\n        if (!Guard.isLiteralBoolean(node.test)) return\r\n        if (!node.test.value) {\r\n          node.test.value = true\r\n          let consequent = node.consequent\r\n          node.consequent = node.alternate\r\n          node.alternate = consequent\r\n        }\r\n\r\n        // node.test.value is true now\r\n        // alternate will be invalid branch\r\n        sp<Identifier>(node.alternate, {\r\n          type: 'Identifier',\r\n          name: 'undefined',\r\n        })\r\n\r\n        sp<Node>(node, node.consequent)\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  logicalExpression(context: Context) {\r\n    walk(context.ast, {\r\n      ExpressionStatement(exst) {\r\n        if (!Guard.isExpressionStatement(exst)) return\r\n        if (!Guard.isLogicalExpression(exst.expression)) return\r\n        if (!Guard.isBinaryExpression(exst.expression.left)) return\r\n        if (!Guard.isSequenceExpression(exst.expression.right)) return\r\n\r\n        const exprs = [...exst.expression.right.expressions].map((e) =>\r\n          (e.type as string) !== 'ExpressionStatement'\r\n            ? {\r\n                type: 'ExpressionStatement',\r\n                start: e.start,\r\n                end: e.end,\r\n                expression: e,\r\n              }\r\n            : e\r\n        ) as Statement[]\r\n\r\n        sp<IfStatement>(exst, {\r\n          type: 'IfStatement',\r\n          test: exst.expression.left,\r\n          consequent: {\r\n            type: 'BlockStatement',\r\n            start: 0,\r\n            end: 0,\r\n            body: exprs,\r\n          },\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  fixup(context: Context) {\r\n    // convert negative numlits to UnaryExpressions\r\n    // negative numlits cause error on codegen\r\n    walk(context.ast, {\r\n      Literal(node) {\r\n        if (!Guard.isLiteralNumeric(node)) return\r\n        if (node.value >= 0) return\r\n        sp<NumericUnaryExpression>(node, {\r\n          type: 'UnaryExpression',\r\n          operator: '-',\r\n          prefix: true,\r\n          argument: { type: 'Literal', value: Math.abs(node.value) } as any,\r\n        })\r\n      },\r\n    })\r\n\r\n    // fix empty VariableDeclarations\r\n    walk(context.ast, {\r\n      VariableDeclaration(node) {\r\n        node.declarations = node.declarations.filter(\r\n          (i) => !i.init || (i.init as any).type !== 'EmptyStatement'\r\n        )\r\n        if (node.declarations.length !== 0) return\r\n        ;(node as any).type = 'EmptyStatement'\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // \"simplify\"\r\n  fixProxies(context: Context) {\r\n    walk(context.ast, {\r\n      CallExpression(cx) {\r\n        if (\r\n          !Guard.isFunctionExpression(cx.callee) &&\r\n          !Guard.isArrowFunctionExpression(cx.callee)\r\n        )\r\n          return\r\n        if (!Guard.isBlockStatement(cx.callee.body)) return\r\n        if (cx.callee.body.body.length !== 1) return\r\n        if (!Guard.isReturnStatement(cx.callee.body.body[0])) return\r\n        const retn = cx.callee.body.body[0].argument\r\n        if (!retn) return\r\n        if (\r\n          [\r\n            'FunctionExpression',\r\n            'ArrowFunctionExpression',\r\n            'FunctionDeclaration',\r\n          ].includes(retn.type)\r\n        ) {\r\n          sp<Function>(cx, retn as unknown as Function)\r\n        } else if (Guard.isCallExpression(retn)) {\r\n          // (function (a, b) {\r\n          //   return b(a());\r\n          // }(f, h));\r\n          //  - to -\r\n          // h(f())\r\n          // potentially move this into its own transformer\r\n          if (\r\n            !cx.arguments.every(\r\n              (a) => Guard.isLiteral(a) || Guard.isIdentifier(a)\r\n            )\r\n          )\r\n            return\r\n          const scope = context.scopeManager.acquire(cx.callee)\r\n          if (!scope) return\r\n          for (const v of scope.variables) {\r\n            if (v.defs.length !== 1) continue\r\n            let def = v.defs[0]\r\n            if (def.type !== 'Parameter') continue\r\n            let pidx = (def as any).index as number\r\n            for (const ref of v.references) {\r\n              sp<any>(ref.identifier, cx.arguments[pidx])\r\n            }\r\n          }\r\n\r\n          sp<CallExpression>(cx, retn)\r\n        }\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.negativeString(context)\r\n      .stringConcat(context)\r\n      .math(context.ast)\r\n      .truthyFalsy(context)\r\n      .literalComparison(context.ast)\r\n      .conditionalExpression(context.ast)\r\n      .singleToBlock(context)\r\n      .fixup(context)\r\n      .logicalExpression(context)\r\n      .fixProxies(context)\r\n  }\r\n}\r\n", "import {\r\n  Program,\r\n  BlockStatement,\r\n  Node,\r\n  sp,\r\n  VariableDeclaration,\r\n  ExpressionStatement,\r\n  ReturnStatement,\r\n  CallExpression,\r\n  FunctionExpression,\r\n  AssignmentExpression,\r\n  StringLiteral,\r\n  Identifier,\r\n  Statement,\r\n  Literal,\r\n  UnaryExpression,\r\n  Expression,\r\n  BinaryExpression,\r\n  VariableDeclarator,\r\n  NumericLiteral,\r\n} from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { walk } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\nimport { immutate, filterEmptyStatements } from '../util/helpers'\r\n\r\nimport Context, {\r\n  DecoderFunction,\r\n  DecoderFunctionBase64,\r\n  DecoderFunctionRC4,\r\n  DecoderFunctionType,\r\n  DecoderReference,\r\n  StringArrayType,\r\n} from '../context'\r\nimport { literalOrUnaryExpressionToNumber } from '../util/translator'\r\nimport Simplify from './simplify'\r\n\r\nexport interface StringDecoderOptions extends TransformerOptions {}\r\nexport default class StringDecoder extends Transformer<StringDecoderOptions> {\r\n  constructor(options: Partial<StringDecoderOptions>) {\r\n    super('StringDecoder', options)\r\n  }\r\n\r\n  private literals_to_arg_array(\r\n    array: Node[]\r\n  ): (string | number | undefined)[] {\r\n    return array.map((n) =>\r\n      Guard.isUnaryExpression(n)\r\n        ? literalOrUnaryExpressionToNumber(n, true)\r\n        : Guard.isLiteral(n)\r\n        ? (n.value as string | number)\r\n        : undefined\r\n    )\r\n  }\r\n\r\n  private util_b64_decode(chars: string, input: string): string {\r\n    let output = '',\r\n      tempEncStr = ''\r\n    for (\r\n      let bc = 0, bs = 0, buffer, idx = 0;\r\n      (buffer = input.charAt(idx++));\r\n      ~buffer && ((bs = bc % 4 ? bs * 64 + buffer : buffer), bc++ % 4)\r\n        ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\r\n        : 0\r\n    ) {\r\n      buffer = chars.indexOf(buffer)\r\n    }\r\n    for (let k = 0, length = output.length; k < length; k++) {\r\n      tempEncStr += '%' + ('00' + output.charCodeAt(k).toString(16)).slice(-2)\r\n    }\r\n    return decodeURIComponent(tempEncStr)\r\n  }\r\n  private util_rc4_decode(chars: string, str: string, key: string): string {\r\n    // sorry\r\n    let s = [],\r\n      j = 0,\r\n      x,\r\n      output = ''\r\n\r\n    str = this.util_b64_decode(chars, str)\r\n\r\n    let i\r\n    for (i = 0; i < 256; i++) {\r\n      s[i] = i\r\n    }\r\n    for (i = 0; i < 256; i++) {\r\n      j = (j + s[i] + key.charCodeAt(i % key.length)) % 256\r\n      x = s[i]\r\n      s[i] = s[j]\r\n      s[j] = x\r\n    }\r\n    i = 0\r\n    j = 0\r\n    for (let y = 0; y < str.length; y++) {\r\n      i = (i + 1) % 256\r\n      j = (j + s[i]) % 256\r\n      x = s[i]\r\n      s[i] = s[j]\r\n      s[j] = x\r\n      output += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256])\r\n    }\r\n    return output\r\n  }\r\n\r\n  private util_decode = (\r\n    context: Context,\r\n    identifier: string,\r\n    args: (string | number | undefined)[]\r\n  ) => {\r\n    // \"\"\"type safety\"\"\"\r\n    let decoder: DecoderFunction,\r\n      offset = 0,\r\n      indexArg = 0,\r\n      keyArg = 1,\r\n      decRef = -1\r\n\r\n    let predicate = (dec: DecoderFunction | DecoderReference) =>\r\n      dec.identifier === identifier\r\n    if (context.stringDecoders.findIndex(predicate) !== -1) {\r\n      decoder = context.stringDecoders.find(predicate)!\r\n    } else if (\r\n      (decRef = context.stringDecoderReferences.findIndex(predicate)) !== -1\r\n    ) {\r\n      let ref = context.stringDecoderReferences[decRef]\r\n      offset += ref.additionalOffset\r\n      let fndDec: DecoderReference | undefined = ref as any\r\n      identifier = ref.realIdentifier\r\n      while (fndDec) {\r\n        fndDec = context.stringDecoderReferences.find(predicate)\r\n        if (fndDec) {\r\n          /*context.log(\r\n            'Resolved parent ref id=',\r\n            identifier,\r\n            'found =',\r\n            fndDec.realIdentifier\r\n          )*/\r\n          offset += fndDec.additionalOffset\r\n          identifier = fndDec.realIdentifier\r\n        }\r\n      }\r\n      decoder = context.stringDecoders.find(predicate)!\r\n      if (typeof ref.indexArgument === 'number') indexArg = ref.indexArgument\r\n      if (typeof ref.keyArgument === 'number') keyArg = ref.keyArgument\r\n    } else {\r\n      throw new TypeError(`Failed to decode ${identifier}, no decoder`)\r\n    }\r\n\r\n    offset += decoder.offset\r\n    let index =\r\n        typeof args[indexArg] === 'string'\r\n          ? parseInt(args[indexArg] as string)\r\n          : (args[indexArg] as number),\r\n      key = ''\r\n\r\n    switch (decoder.type) {\r\n      case DecoderFunctionType.SIMPLE:\r\n        return this.decodeSimple(context, identifier, index, offset)\r\n      case DecoderFunctionType.BASE64:\r\n        return this.decodeBase64(context, identifier, index, offset)\r\n      case DecoderFunctionType.RC4:\r\n        key = args[keyArg] as string\r\n        return this.decodeRC4(context, identifier, index, key, offset)\r\n      default:\r\n        throw new TypeError('Invalid decoder function type')\r\n    }\r\n  }\r\n\r\n  getString = (\r\n    context: Context,\r\n    decoderIdentifier: string,\r\n    index: number,\r\n    offset: number\r\n  ): string => {\r\n    const stringDecoder = context.stringDecoders.find(\r\n      (i) => i.identifier === decoderIdentifier\r\n    )\r\n    if (!stringDecoder)\r\n      throw new Error(\r\n        `Failed to find string decoder with identifier \"${decoderIdentifier}\"`\r\n      )\r\n\r\n    const strArray = context.stringArrays.find(\r\n      (i) => i.identifier === stringDecoder.stringArrayIdentifier\r\n    )\r\n    if (!strArray)\r\n      throw new Error(\r\n        `Failed to find string array with identifier \"${stringDecoder.stringArrayIdentifier}\"`\r\n      )\r\n\r\n    return strArray.strings[index + offset]\r\n  }\r\n\r\n  decodeSimple(\r\n    context: Context,\r\n    identifier: string,\r\n    index: number,\r\n    offset: number\r\n  ) {\r\n    return this.getString(context, identifier, index, offset)\r\n  }\r\n  decodeBase64(\r\n    context: Context,\r\n    identifier: string, // grab the charset from our identifier\r\n    index: number,\r\n    offset: number\r\n  ) {\r\n    let str = this.getString(context, identifier, index, offset),\r\n      charset = (\r\n        context.stringDecoders.find(\r\n          (d) =>\r\n            d.identifier === identifier && d.type === DecoderFunctionType.BASE64\r\n        ) as DecoderFunctionBase64\r\n      ).charset\r\n    return this.util_b64_decode(charset, str)\r\n  }\r\n  decodeRC4(\r\n    context: Context,\r\n    identifier: string,\r\n    index: number,\r\n    key: string,\r\n    offset: number\r\n  ) {\r\n    let str = this.getString(context, identifier, index, offset),\r\n      charset = (\r\n        context.stringDecoders.find(\r\n          (d) =>\r\n            d.identifier === identifier && d.type === DecoderFunctionType.RC4\r\n        ) as DecoderFunctionRC4\r\n      ).charset\r\n    return this.util_rc4_decode(charset, str, key)\r\n  }\r\n\r\n  // Find the string array automatically\r\n  // !! Must match to hardcoded function schema !!\r\n  stringsFinder(context: Context) {\r\n    // look for array\r\n    if (context.stringArrays.some((i) => i.type === StringArrayType.ARRAY)) {\r\n      walk(context.ast, {\r\n        VariableDeclaration(node, _, ancestors) {\r\n          let rm: string[] = []\r\n          for (const vd of node.declarations) {\r\n            if (!Guard.isIdentifier(vd.id)) continue\r\n            if (!vd.init || !Guard.isArrayExpression(vd.init)) continue\r\n            const identifier = vd.id.name\r\n            if (\r\n              !context.stringArrays.find(\r\n                (i) =>\r\n                  i.type === StringArrayType.ARRAY &&\r\n                  i.identifier === identifier\r\n              )\r\n            )\r\n              continue\r\n\r\n            if (!vd.init.elements.every((e) => Guard.isLiteralString(e as any)))\r\n              continue\r\n            const strArray = context.stringArrays.find(\r\n              (i) => i.identifier === identifier\r\n            )!\r\n            strArray.strings = (vd.init.elements as StringLiteral[]).map(\r\n              (e) => e.value\r\n            ) as string[]\r\n\r\n            context.log(\r\n              'Found string array at',\r\n              strArray.identifier,\r\n              '#',\r\n              strArray.strings.length\r\n            )\r\n            rm.push(`${vd.start}!${vd.end}`)\r\n          }\r\n\r\n          node.declarations = node.declarations.filter(\r\n            (d) => !rm.includes(`${d.start}!${d.end}`)\r\n          )\r\n        },\r\n      })\r\n    }\r\n\r\n    walk(context.ast, {\r\n      FunctionDeclaration(node) {\r\n        const block = node.body\r\n        if (block.body.length !== 3) return // Not a proxy string array fn\r\n        // user typeguards dont work on array elements :)))))))))))))\r\n        if (!Guard.isVariableDeclaration(block.body[0])) return\r\n        if (!Guard.isExpressionStatement(block.body[1])) return\r\n        if (!Guard.isReturnStatement(block.body[2])) return\r\n\r\n        if (!Guard.isIdentifier(block.body[0].declarations[0].id)) return\r\n        if (\r\n          !block.body[0].declarations[0].init ||\r\n          block.body[0].declarations[0].init?.type !== 'ArrayExpression' // `init?: Expression | null | undefined` ??????\r\n        )\r\n          return\r\n        let fnId = node.id?.name,\r\n          strArrayId = block.body[0].declarations[0].id.name,\r\n          strArray = block.body[0].declarations[0].init\r\n        if (\r\n          !Guard.isAssignmentExpression(block.body[1].expression) ||\r\n          !Guard.isIdentifier(block.body[1].expression.left) ||\r\n          block.body[1].expression.left.name !== fnId ||\r\n          !Guard.isFunctionExpression(block.body[1].expression.right) ||\r\n          !Guard.isReturnStatement(\r\n            block.body[1].expression.right.body.body[0]\r\n          ) ||\r\n          block.body[1].expression.right.body.body[0].argument?.type !==\r\n            'Identifier' ||\r\n          block.body[1].expression.right.body.body[0].argument.name !==\r\n            strArrayId\r\n        )\r\n          return\r\n        if (!strArray.elements.every((e) => Guard.isLiteralString(e as any)))\r\n          return\r\n\r\n        const strArrayObj = {\r\n          identifier: fnId,\r\n          type: StringArrayType.FUNCTION,\r\n          strings: (strArray.elements as StringLiteral[]).map((e) => e.value),\r\n        }\r\n        if (context.removeGarbage) {\r\n          ;(node as any).type = 'EmptyStatement'\r\n        }\r\n        context.stringArrays.push(strArrayObj)\r\n        context.log(\r\n          'Found string array at',\r\n          strArrayObj.identifier,\r\n          '#',\r\n          strArrayObj.strings.length\r\n        )\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  funcFinder(context: Context) {\r\n    walk(context.ast, {\r\n      FunctionDeclaration(node) {\r\n        if (!node.id) return\r\n        const block = node.body\r\n        const fnId = node.id.name\r\n\r\n        if (block.body.length > 3 && block.body.length < 1) return\r\n        if (!block.body[0]) return\r\n        // stringArray declaration\r\n        if (\r\n          !Guard.isVariableDeclaration(block.body[0]) &&\r\n          block.body.length !== 1\r\n        )\r\n          return\r\n        let retn = block.body[block.body.length - 1]\r\n        if (!Guard.isReturnStatement(retn) || !retn.argument) return\r\n        let fn: FunctionExpression,\r\n          ae: AssignmentExpression | undefined = undefined\r\n\r\n        if (retn.argument.type === 'SequenceExpression') {\r\n          if (\r\n            !Guard.isReturnStatement(retn) ||\r\n            retn.argument?.type !== 'SequenceExpression' ||\r\n            retn.argument.expressions.length !== 2 ||\r\n            !Guard.isAssignmentExpression(retn.argument.expressions[0]) ||\r\n            !Guard.isCallExpression(retn.argument.expressions[1])\r\n            // check callexp callee and args?\r\n          )\r\n            return\r\n          ae = retn.argument.expressions[0]\r\n        } else if (retn.argument.type === 'CallExpression') {\r\n          if (\r\n            !Guard.isIdentifier(retn.argument.callee) ||\r\n            retn.argument.callee.name !== fnId ||\r\n            !Guard.isExpressionStatement(block.body[1]) ||\r\n            !Guard.isAssignmentExpression(block.body[1].expression)\r\n          )\r\n            return\r\n\r\n          ae = block.body[1].expression\r\n        }\r\n\r\n        if (!ae) return\r\n\r\n        if (\r\n          !Guard.isIdentifier(ae.left) ||\r\n          ae.left.name !== fnId ||\r\n          !Guard.isFunctionExpression(ae.right)\r\n        )\r\n          return\r\n        fn = ae.right\r\n\r\n        const stringArrayNames = context.stringArrays.map((i) => i.identifier)\r\n        let ourStringArray = ''\r\n\r\n        if (\r\n          block.body.length !== 1 &&\r\n          Guard.isVariableDeclaration(block.body[0])\r\n        ) {\r\n          if (\r\n            block.body[0].declarations[0].init?.type !== 'CallExpression' ||\r\n            block.body[0].declarations[0].init.callee.type !== 'Identifier' ||\r\n            !stringArrayNames.includes(\r\n              block.body[0].declarations[0].init.callee.name\r\n            )\r\n          )\r\n            return\r\n\r\n          ourStringArray = block.body[0].declarations[0].init.callee.name\r\n        }\r\n        const body = fn.body.body as Statement[]\r\n        if (block.body.length === 1) {\r\n          if (\r\n            !body[1] ||\r\n            !Guard.isVariableDeclaration(body[1]) ||\r\n            body[1].declarations[0].init?.type !== 'MemberExpression' ||\r\n            !Guard.isIdentifier(body[1].declarations[0].init.object) ||\r\n            !Guard.isIdentifier(body[1].declarations[0].init.property)\r\n          )\r\n            return\r\n          // array reference, not function\r\n          // locate the stringArray after funcFinder is ran\r\n\r\n          ourStringArray = body[1].declarations[0].init.object.name\r\n          let strArrayObj = {\r\n            identifier: ourStringArray,\r\n            type: StringArrayType.ARRAY,\r\n            strings: [],\r\n          }\r\n          context.stringArrays.push(strArrayObj)\r\n          context.log(\r\n            'Added',\r\n            strArrayObj.identifier,\r\n            'as a string array to be found'\r\n          )\r\n        }\r\n\r\n        let calcOffset = 0\r\n        if (\r\n          !Guard.isExpressionStatement(body[0]) ||\r\n          !Guard.isAssignmentExpression(body[0].expression) ||\r\n          !Guard.isBinaryExpression(body[0].expression.right) ||\r\n          (!Guard.isLiteral(body[0].expression.right.right) &&\r\n            !Guard.isUnaryExpression(body[0].expression.right.right))\r\n        )\r\n          return\r\n\r\n        // our offset in our code will always be ADDED to the index,\r\n        // not subtracted.\r\n        calcOffset = literalOrUnaryExpressionToNumber(\r\n          body[0].expression.right.right\r\n        )\r\n        if (body[0].expression.right.operator === '-')\r\n          calcOffset = calcOffset * -1\r\n\r\n        let decFn = {\r\n          identifier: node.id.name,\r\n          stringArrayIdentifier: ourStringArray,\r\n          offset: calcOffset,\r\n          type: DecoderFunctionType.SIMPLE,\r\n          indexArgument: 0,\r\n          keyArgument: 1,\r\n        } as DecoderFunction\r\n\r\n        if (body.length >= 3) {\r\n          // possibly B64/RC4 type decoder\r\n          if (Guard.isIfStatement(body[2])) {\r\n            // check for B64 charset\r\n\r\n            if (!Guard.isBlockStatement(body[2].consequent)) return\r\n            if (body[2].consequent.body.length <= 1) return\r\n            if (\r\n              Guard.isExpressionStatement(body[2].consequent.body[0]) &&\r\n              Guard.isAssignmentExpression(\r\n                body[2].consequent.body[0].expression\r\n              )\r\n            ) {\r\n              sp<VariableDeclaration>(body[2].consequent.body[0], {\r\n                type: 'VariableDeclaration',\r\n                declarations: [\r\n                  {\r\n                    type: 'VariableDeclarator',\r\n                    start: 0,\r\n                    end: 0,\r\n                    id: {\r\n                      type: 'Identifier',\r\n                      start: 0,\r\n                      end: 0,\r\n                      name: 'b64dec',\r\n                    },\r\n                    init: body[2].consequent.body[0].expression.right,\r\n                  },\r\n                ],\r\n              })\r\n            }\r\n            if (\r\n              Guard.isExpressionStatement(body[2].consequent.body[1]) &&\r\n              Guard.isAssignmentExpression(\r\n                body[2].consequent.body[1].expression\r\n              )\r\n            ) {\r\n              sp<VariableDeclaration>(body[2].consequent.body[1], {\r\n                type: 'VariableDeclaration',\r\n                declarations: [\r\n                  {\r\n                    type: 'VariableDeclarator',\r\n                    start: 0,\r\n                    end: 0,\r\n                    id: {\r\n                      type: 'Identifier',\r\n                      start: 0,\r\n                      end: 0,\r\n                      name: 'rc4dec',\r\n                    },\r\n                    init: body[2].consequent.body[1].expression.right,\r\n                  },\r\n                ],\r\n              })\r\n            }\r\n\r\n            if (\r\n              Guard.isVariableDeclaration(body[2].consequent.body[0]) &&\r\n              Guard.isFunctionExpression(\r\n                body[2].consequent.body[0].declarations[0].init!\r\n              ) &&\r\n              (!Guard.isVariableDeclaration(body[2].consequent.body[1]) ||\r\n                !Guard.isFunctionExpression(\r\n                  body[2].consequent.body[1].declarations[0].init!\r\n                ))\r\n            ) {\r\n              let fx = body[2].consequent.body[0].declarations[0].init,\r\n                fxb = fx.body.body\r\n              if (Guard.isVariableDeclaration(fxb[0])) {\r\n                if (Guard.isLiteralString(fxb[0].declarations[0].init!)) {\r\n                  let charset = fxb[0].declarations[0].init.value\r\n                  if (charset.length === 65) {\r\n                    // charset declaration\r\n                    decFn.type = DecoderFunctionType.BASE64\r\n                    ;(decFn as DecoderFunctionBase64).charset = charset\r\n                  }\r\n                }\r\n              }\r\n            } else if (\r\n              body[2].consequent.body.length >= 3 &&\r\n              // b64\r\n              Guard.isVariableDeclaration(body[2].consequent.body[0]) &&\r\n              Guard.isFunctionExpression(\r\n                body[2].consequent.body[0].declarations[0].init!\r\n              ) &&\r\n              // rc4\r\n              Guard.isVariableDeclaration(body[2].consequent.body[1]) &&\r\n              Guard.isFunctionExpression(\r\n                body[2].consequent.body[1].declarations[0].init!\r\n              )\r\n            ) {\r\n              let fx = body[2].consequent.body[0].declarations[0].init,\r\n                fxb = fx.body.body\r\n              if (Guard.isVariableDeclaration(fxb[0])) {\r\n                if (Guard.isLiteralString(fxb[0].declarations[0].init!)) {\r\n                  let charset = fxb[0].declarations[0].init.value\r\n                  if (charset.length === 65) {\r\n                    // charset declaration\r\n\r\n                    decFn.type = DecoderFunctionType.RC4\r\n                    ;(decFn as DecoderFunctionRC4).charset = charset\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        context.stringDecoders.push(decFn)\r\n        if (context.removeGarbage) {\r\n          ;(node as any).type = 'EmptyStatement'\r\n        }\r\n        context.log(\r\n          'Found decoder function',\r\n          node.id?.name,\r\n          'arrayId =',\r\n          decFn.stringArrayIdentifier,\r\n          'offset =',\r\n          calcOffset,\r\n          'type =',\r\n          decFn.type\r\n        )\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  calcShift = (\r\n    context: Context,\r\n    breakCond: number,\r\n    stringArrayIdent: string,\r\n    parseIntChain: BinaryExpression\r\n  ) => {\r\n    const { util_decode, literals_to_arg_array } = this\r\n    const st = new Simplify({})\r\n    // String eval loop\r\n    // push/shift should only have #size unique combinations I think\r\n\r\n    const stringArray = context.stringArrays.find(\r\n      (i) => i.identifier === stringArrayIdent\r\n    )!\r\n    let maxLoops = stringArray.strings.length * 2,\r\n      iteration = 0\r\n    while (true) {\r\n      iteration++\r\n      if (iteration > maxLoops) {\r\n        throw new Error(\r\n          `Push/shift calculation failed (iter=${iteration}>maxLoops=${maxLoops})`\r\n        )\r\n      }\r\n      // Classes suck\r\n      const bpic = immutate(parseIntChain)\r\n      let hasNaN = false\r\n\r\n      stringArray.strings.push(stringArray.strings.shift() as string)\r\n\r\n      // convert -?parseInt(strdec(idx)) / n [+*] $0 chain\r\n      walk(bpic, {\r\n        CallExpression(node) {\r\n          // find parseInts\r\n          if (\r\n            !Guard.isIdentifier(node.callee) ||\r\n            node.callee.name !== 'parseInt'\r\n          )\r\n            return\r\n\r\n          if (\r\n            node.arguments.length !== 1 ||\r\n            node.arguments[0].type !== 'CallExpression' ||\r\n            node.arguments[0].callee.type !== 'Identifier' ||\r\n            node.arguments[0].arguments.length === 0 ||\r\n            node.arguments[0].arguments.length > 5\r\n          )\r\n            return\r\n\r\n          if (\r\n            node.arguments[0].arguments[0].type !== 'Literal' &&\r\n            node.arguments[0].arguments[0].type !== 'UnaryExpression'\r\n          )\r\n            return\r\n          let val = -1\r\n          try {\r\n            let args = literals_to_arg_array(node.arguments[0].arguments)\r\n            val = parseInt(\r\n              util_decode(context, node.arguments[0].callee.name, args)\r\n            )\r\n          } catch (err) {\r\n            throw err\r\n          }\r\n\r\n          if (isNaN(val)) {\r\n            sp<Identifier>(node, {\r\n              type: 'Identifier',\r\n              name: 'NaN',\r\n            })\r\n            hasNaN = true\r\n          } else {\r\n            sp<Literal>(node, {\r\n              type: 'Literal',\r\n              value: val,\r\n            })\r\n          }\r\n        },\r\n      })\r\n\r\n      if (hasNaN) {\r\n        continue\r\n      } else {\r\n        // use our SimplifyTransformer to calculate end value\r\n        st.math(bpic)\r\n        if (\r\n          (bpic as any).type === 'Literal' &&\r\n          (bpic as Literal).value === breakCond\r\n        )\r\n          break\r\n      }\r\n    }\r\n    context.shiftedArrays++\r\n  }\r\n\r\n  // Locate push/shift pair inside IIFE\r\n  shiftFinder(context: Context) {\r\n    const { calcShift } = this\r\n    // retn TRUE if remove .\r\n    function visitor(node: Node) {\r\n      if (\r\n        !Guard.isCallExpression(node) ||\r\n        node.callee.type !== 'FunctionExpression'\r\n      )\r\n        return false\r\n\r\n      const body = node.callee.body.body,\r\n        bRev = [...body].reverse()\r\n\r\n      if (body.length < 2) return\r\n      let loopBody: Statement[]\r\n      if (bRev[0].type === 'ForStatement') {\r\n        if (!Guard.isBlockStatement(bRev[0].body)) return\r\n        loopBody = filterEmptyStatements(bRev[0].body.body) as Statement[]\r\n      } else if (bRev[0].type === 'WhileStatement') {\r\n        if (!Guard.isBlockStatement(bRev[0].body)) return\r\n        loopBody = filterEmptyStatements(bRev[0].body.body) as Statement[]\r\n      } else {\r\n        return\r\n      }\r\n      if (\r\n        loopBody.length !== 1 ||\r\n        loopBody[0].type !== 'TryStatement' ||\r\n        filterEmptyStatements(loopBody[0].block.body).length !== 2\r\n      )\r\n        return\r\n      let blockBody = filterEmptyStatements(loopBody[0].block.body)\r\n\r\n      // string array id\r\n      if (node.arguments.length !== 2) return\r\n      if (node.arguments[0].type !== 'Identifier') return\r\n      if (node.arguments[1].type !== 'Literal') return\r\n      const breakCond = node.arguments[1].value\r\n      let pic: Expression\r\n\r\n      if (blockBody[0].type === 'VariableDeclaration') {\r\n        if (!blockBody[0].declarations[0].init) return\r\n        pic = blockBody[0].declarations[0].init as Expression\r\n      } else if (blockBody[0].type === 'IfStatement') {\r\n        if (\r\n          !Guard.isBinaryExpression(blockBody[0].test) ||\r\n          blockBody[0].test.operator !== '==='\r\n        )\r\n          return\r\n        if (\r\n          !Guard.isLiteralNumeric(blockBody[0].test.left) ||\r\n          blockBody[0].test.left.value !== breakCond\r\n        )\r\n          return\r\n        pic = blockBody[0].test.right\r\n      } else {\r\n        return\r\n      }\r\n\r\n      //pic = loopBody[0].block.body[0].declarations[0].init\r\n      if (pic.type !== 'BinaryExpression') return\r\n\r\n      const stringArrayIdent = node.arguments[0].name\r\n\r\n      const stringArray = context.stringArrays.find(\r\n        (i) => i.identifier === stringArrayIdent\r\n      )\r\n      if (!stringArray)\r\n        throw new Error(\r\n          `Failed to find string array with identifier \"${stringArrayIdent}\" for push/shift calc`\r\n        )\r\n\r\n      calcShift(context, breakCond as number, stringArray.identifier, pic)\r\n      context.log('Found push/shift IIFE breakCond =', breakCond)\r\n      if (context.removeGarbage) {\r\n        return true\r\n      }\r\n      return false\r\n    }\r\n    walk(context.ast, {\r\n      ExpressionStatement(node) {\r\n        if (Guard.isSequenceExpression(node.expression)) {\r\n          let rm: string[] = []\r\n          for (const exp of node.expression.expressions) {\r\n            if (visitor(exp)) rm.push(`${exp.start}!${exp.end}`)\r\n          }\r\n          if (rm) {\r\n            node.expression.expressions = node.expression.expressions.filter(\r\n              (d) => !rm.includes(`${d.start}!${d.end}`)\r\n            )\r\n          }\r\n        } else {\r\n          if (visitor(node.expression)) {\r\n            ;(node as any).type = 'EmptyStatement'\r\n          }\r\n        }\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  shiftFinder2(context: Context) {\r\n    const { calcShift } = this\r\n    function visitor(node: Node) {\r\n      if (\r\n        !Guard.isCallExpression(node) ||\r\n        node.callee.type !== 'FunctionExpression'\r\n      )\r\n        return false\r\n\r\n      const body = node.callee.body.body,\r\n        bRev = [...body].reverse()\r\n\r\n      const scope = context.scopeManager.acquire(node.callee)\r\n      if (!scope) return\r\n\r\n      let foundPushShift = false,\r\n        stringArrayRef: string\r\n\r\n      walk(node, {\r\n        ExpressionStatement(exp) {\r\n          if (!Guard.isCallExpression(exp.expression)) return\r\n          if (exp.expression.arguments.length === 0) return\r\n          if (!Guard.isMemberExpression(exp.expression.callee)) return\r\n          if (!Guard.isIdentifier(exp.expression.callee.object)) return\r\n          if (!Guard.isIdentifier(exp.expression.callee.property)) return\r\n          stringArrayRef = exp.expression.callee.object.name\r\n\r\n          if (exp.expression.callee.property.name !== 'push') return\r\n          const arg = exp.expression.arguments[0]\r\n          if (!Guard.isCallExpression(arg)) return\r\n          if (arg.arguments.length !== 0) return\r\n          if (!Guard.isMemberExpression(arg.callee)) return\r\n          if (!Guard.isIdentifier(arg.callee.object)) return\r\n          if (!Guard.isIdentifier(arg.callee.property)) return\r\n          if (arg.callee.object.name !== stringArrayRef) return\r\n          if (arg.callee.property.name !== 'shift') return\r\n          foundPushShift = true\r\n        },\r\n      })\r\n      if (!foundPushShift) return false\r\n\r\n      let foundStringArrayVar = scope.variables.find(\r\n        (i) => i.name === stringArrayRef\r\n      )\r\n      if (!foundStringArrayVar) return false\r\n\r\n      if (foundStringArrayVar.defs.length === 0) return false\r\n      const def = foundStringArrayVar.defs[0],\r\n        dnode = def.node as VariableDeclarator\r\n      if (dnode.type !== 'VariableDeclarator') return false\r\n      if (!dnode.init || !Guard.isCallExpression(dnode.init)) return false\r\n\r\n      if (!Guard.isIdentifier(dnode.init.callee)) return false\r\n      const stringArrayName = dnode.init.callee.name\r\n      const stringArrayFunc = context.stringArrays.find(\r\n        (i) => i.identifier === stringArrayName\r\n      )\r\n      if (!stringArrayFunc) return false\r\n\r\n      let foundBinExp = false,\r\n        breakCond: number | undefined,\r\n        pic: BinaryExpression | undefined\r\n      walk(node, {\r\n        IfStatement(ifs) {\r\n          if (!Guard.isBinaryExpression(ifs.test)) return\r\n          if (ifs.test.operator !== '==' && ifs.test.operator !== '===') return\r\n          let bc: NumericLiteral | undefined, bx: BinaryExpression | undefined\r\n          if (Guard.isLiteralNumeric(ifs.test.left)) {\r\n            if (!Guard.isBinaryExpression(ifs.test.right)) return\r\n            bc = ifs.test.left\r\n            bx = ifs.test.right\r\n          } else if (Guard.isLiteralNumeric(ifs.test.right)) {\r\n            if (!Guard.isBinaryExpression(ifs.test.left)) return\r\n            bc = ifs.test.right\r\n            bx = ifs.test.left\r\n          }\r\n\r\n          if (!bc || !bx) return\r\n          pic = bx\r\n          breakCond = bc.value\r\n          foundBinExp = true\r\n        },\r\n      })\r\n      if (!foundBinExp || !breakCond || !pic) return false\r\n\r\n      context.log(\r\n        'Found push/shift (#2) IIFE stringArray =',\r\n        stringArrayFunc.identifier,\r\n        'breakCond =',\r\n        breakCond\r\n      )\r\n      calcShift(context, breakCond, stringArrayFunc.identifier, pic)\r\n\r\n      return true\r\n    }\r\n    walk(context.ast, {\r\n      ExpressionStatement(node) {\r\n        if (Guard.isSequenceExpression(node.expression)) {\r\n          let rm: string[] = []\r\n          for (const exp of node.expression.expressions) {\r\n            if (visitor(exp)) rm.push(`${exp.start}!${exp.end}`)\r\n          }\r\n          if (rm) {\r\n            node.expression.expressions = node.expression.expressions.filter(\r\n              (d) => !rm.includes(`${d.start}!${d.end}`)\r\n            )\r\n          }\r\n        } else if (Guard.isUnaryExpression(node.expression)) {\r\n          if (!Guard.isCallExpression(node.expression.argument)) return\r\n          if (visitor(node.expression.argument)) {\r\n            ;(node as any).type = 'EmptyStatement'\r\n          }\r\n        } else {\r\n          if (visitor(node.expression)) {\r\n            ;(node as any).type = 'EmptyStatement'\r\n          }\r\n        }\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // Scan for variable references to the decoder functions\r\n  varReferenceFinder(context: Context) {\r\n    let newRefsFound = 0\r\n    walk(context.ast, {\r\n      VariableDeclaration(vd) {\r\n        let rm: string[] = []\r\n        for (const decl of vd.declarations) {\r\n          if (decl.init?.type !== 'Identifier' || decl.id.type !== 'Identifier')\r\n            continue\r\n          let refName = decl.id.name,\r\n            valName = decl.init.name\r\n          let foundDecoder: DecoderFunction | DecoderReference | undefined =\r\n            context.stringDecoders.find((d) => d.identifier === valName)\r\n          if (!foundDecoder) {\r\n            foundDecoder = context.stringDecoderReferences.find(\r\n              (d) => d.identifier === valName\r\n            )\r\n            if (!foundDecoder) continue\r\n          }\r\n          context.log('Found variable reference', refName, valName)\r\n          context.stringDecoderReferences.push({\r\n            identifier: refName,\r\n            realIdentifier: valName,\r\n            additionalOffset: 0,\r\n          })\r\n          newRefsFound++\r\n          if (context.removeGarbage) {\r\n            rm.push(`${decl.start}!${decl.end}`)\r\n          }\r\n        }\r\n        vd.declarations = vd.declarations.filter(\r\n          (d) => !rm.includes(`${d.start}!${d.end}`)\r\n        )\r\n        if (vd.declarations.length === 0) {\r\n          // this node wont generate if it has no declarations left\r\n          ;(vd as any).type = 'EmptyStatement'\r\n        }\r\n      },\r\n    })\r\n    return newRefsFound\r\n  }\r\n\r\n  // Scan for function references to the decoder functions and their references\r\n  fnReferenceFinder(context: Context) {\r\n    let newRefsFound = 0\r\n    walk(context.ast, {\r\n      FunctionDeclaration(node) {\r\n        let body = filterEmptyStatements(node.body.body)\r\n        if (\r\n          !node.id ||\r\n          body.length !== 1 ||\r\n          !Guard.isReturnStatement(body[0]) ||\r\n          !node.params.every((p) => Guard.isIdentifier(p)) ||\r\n          !body[0].argument ||\r\n          !Guard.isCallExpression(body[0].argument) ||\r\n          !Guard.isIdentifier(body[0].argument.callee)\r\n        )\r\n          return\r\n        const fnId = node.id.name,\r\n          retn = body[0],\r\n          cx = body[0].argument!\r\n        const calleeId = (cx.callee as Identifier).name\r\n        let i = 0,\r\n          offset = 0,\r\n          indexArg = -1,\r\n          keyArg = -1\r\n\r\n        const parent = {\r\n          identifier: '',\r\n          indexArgument: -1,\r\n          keyArgument: -1,\r\n        }\r\n\r\n        const parentFn = context.stringDecoders.find(\r\n          (dec) => dec.identifier === calleeId\r\n        )\r\n        if (!parentFn) {\r\n          // check for ref\r\n          const ref = context.stringDecoderReferences.find(\r\n            (dec) => dec.identifier === calleeId\r\n          )\r\n          if (!ref) return\r\n          parent.identifier = ref.identifier\r\n          parent.indexArgument = ref.indexArgument!\r\n          parent.keyArgument = ref.keyArgument!\r\n        } else {\r\n          parent.identifier = parentFn.identifier\r\n          parent.indexArgument = parentFn.indexArgument\r\n          parent.keyArgument = parentFn.keyArgument\r\n        }\r\n\r\n        const params = (node.params as Identifier[]).map((id) => id.name),\r\n          args = cx.arguments\r\n\r\n        for (const arg of args) {\r\n          walk(arg, {\r\n            Identifier(ident) {\r\n              if (!params.includes(ident.name)) return\r\n              if (i === parent.indexArgument) {\r\n                indexArg = params.indexOf(ident.name)\r\n              } else if (i === parent.keyArgument) {\r\n                keyArg = params.indexOf(ident.name)\r\n              }\r\n            },\r\n            BinaryExpression(bx) {\r\n              let num = NaN\r\n              if (i !== parent.indexArgument) return\r\n              if (\r\n                Guard.isUnaryExpression(bx.left) ||\r\n                Guard.isLiteralNumeric(bx.left) ||\r\n                Guard.isLiteralString(bx.left)\r\n              ) {\r\n                num = literalOrUnaryExpressionToNumber(bx.left, true)\r\n              } else if (\r\n                Guard.isUnaryExpression(bx.right) ||\r\n                Guard.isLiteralNumeric(bx.right) ||\r\n                Guard.isLiteralString(bx.right)\r\n              ) {\r\n                num = literalOrUnaryExpressionToNumber(bx.right, true)\r\n              }\r\n              if (isNaN(num)) return\r\n              if (bx.operator === '-') num = num * -1\r\n              offset = num\r\n            },\r\n          })\r\n          ++i\r\n        }\r\n        if (context.stringDecoderReferences.find((i) => i.identifier === fnId))\r\n          return\r\n        context.stringDecoderReferences.push({\r\n          identifier: fnId,\r\n          realIdentifier: parent.identifier,\r\n          additionalOffset: offset,\r\n          indexArgument: indexArg,\r\n          keyArgument: keyArg,\r\n        })\r\n        newRefsFound++\r\n        if (context.removeGarbage) {\r\n          ;(node as any).type = 'EmptyStatement'\r\n        }\r\n        context.log(\r\n          'Found func ref id =',\r\n          fnId,\r\n          'offset =',\r\n          offset,\r\n          'index =',\r\n          indexArg,\r\n          'key =',\r\n          keyArg,\r\n          'parent =',\r\n          parent.identifier\r\n        )\r\n      },\r\n    })\r\n    return newRefsFound\r\n  }\r\n\r\n  // Decode everything\r\n  decoder(context: Context) {\r\n    const { util_decode, literals_to_arg_array } = this\r\n\r\n    walk(context.ast, {\r\n      CallExpression(node) {\r\n        if (\r\n          node.callee.type !== 'Identifier' ||\r\n          node.arguments.length === 0 ||\r\n          node.arguments.length > 5 ||\r\n          node.arguments[0].type === 'SpreadElement'\r\n        )\r\n          return\r\n        if (\r\n          !node.arguments.every(\r\n            (node) =>\r\n              Guard.isUnaryExpressionNumeric(node) ||\r\n              Guard.isLiteralNumeric(node) ||\r\n              Guard.isLiteralString(node)\r\n          )\r\n        )\r\n          return\r\n\r\n        const name = node.callee.name\r\n\r\n        if (name === 'parseInt') return\r\n        try {\r\n          let args = literals_to_arg_array(node.arguments)\r\n          let val = util_decode(context, name, args)\r\n          sp<Literal>(node, {\r\n            type: 'Literal',\r\n            value: val,\r\n          })\r\n        } catch (err: any) {\r\n          if (err.toString().includes('no decoder')) return\r\n          throw err\r\n        }\r\n        /*let foundRef = context.stringDecoderReferences.find(\r\n          (ref) => ref.identifier === name\r\n        )\r\n        if (!foundRef) return // not a string decode call\r\n\r\n        // foundRef is not undefined thank u TS\r\n        let foundDec = context.stringDecoders.find(\r\n          (dec) => dec.identifier === foundRef!.realIdentifier\r\n        )\r\n        if (!foundDec) return*/\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.stringsFinder(context).funcFinder(context).stringsFinder(context)\r\n\r\n    while (this.varReferenceFinder(context) > 0) {\r\n      context.log('Searching for more variable references')\r\n    }\r\n    while (this.fnReferenceFinder(context) > 0) {\r\n      context.log('Searching for more function references')\r\n    }\r\n\r\n    this.shiftFinder(context).shiftFinder2(context).decoder(context)\r\n\r\n    context.log(\r\n      'shifted =',\r\n      context.shiftedArrays,\r\n      'arrays =',\r\n      context.stringArrays.length\r\n    )\r\n  }\r\n}\r\n", "import { Transformer, TransformerOptions } from './transformer'\r\nimport { walk, findNodeAt } from '../util/walk'\r\nimport {\r\n  Function,\r\n  IfStatement,\r\n  sp,\r\n  VariableDeclaration,\r\n  VariableDeclarator,\r\n} from '../util/types'\r\nimport * as Guard from '../util/guard'\r\nimport Context from '../context'\r\n\r\nexport interface DeadCodeOptions extends TransformerOptions {}\r\nexport default class DeadCode extends Transformer<DeadCodeOptions> {\r\n  constructor(options: Partial<DeadCodeOptions>) {\r\n    super('DeadCode', options)\r\n  }\r\n\r\n  // flip alternate/consequent if test is FALSE\r\n  flipIfStatements(context: Context) {\r\n    walk(context.ast, {\r\n      IfStatement(node) {\r\n        if (!node.alternate) return\r\n\r\n        if (!Guard.isLiteralBoolean(node.test) || node.test.value !== false)\r\n          return\r\n\r\n        if (\r\n          Guard.isIfStatement(node.alternate) &&\r\n          (!Guard.isLiteralBoolean(node.alternate.test) ||\r\n            node.alternate.test.value !== true ||\r\n            node.alternate.alternate)\r\n        )\r\n          return\r\n\r\n        let cons = node.consequent,\r\n          alt = Guard.isIfStatement(node.alternate)\r\n            ? node.alternate.consequent\r\n            : node.alternate\r\n\r\n        node.test.value = !node.test.value\r\n        sp<IfStatement>(node, {\r\n          consequent: alt as any,\r\n          alternate: cons as any,\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // remove alternates if test is TRUE\r\n  removeDeadAlternates(context: Context) {\r\n    walk(context.ast, {\r\n      IfStatement(node) {\r\n        if (!node.alternate) return\r\n        if (!Guard.isLiteralBoolean(node.test) || node.test.value !== true)\r\n          return\r\n        if (Guard.isIfStatement(node.alternate)) return\r\n\r\n        delete node.alternate\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // move if (true) consequents to parent if no alternate flow\r\n  fixIfStatements(context: Context) {\r\n    walk(context.ast, {\r\n      IfStatement(node, _, ancestors) {\r\n        if (node.alternate) return\r\n        if (!Guard.isLiteralBoolean(node.test) || node.test.value !== true)\r\n          return\r\n\r\n        let parent = ancestors[ancestors.length - 2]\r\n        if (\r\n          !Guard.isBlockStatement(parent) ||\r\n          !Guard.isBlockStatement(node.consequent)\r\n        )\r\n          return\r\n\r\n        let ourIdx = parent.body.findIndex(\r\n          (n) =>\r\n            n.type === node.type && n.start === node.start && n.end === node.end\r\n        )\r\n        parent.body.splice(ourIdx, 1, ...node.consequent.body)\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // remove if(false), while(false)\r\n  removeDead(context: Context) {\r\n    walk(context.ast, {\r\n      IfStatement(node, _, ancestors) {\r\n        const parent = ancestors[ancestors.length - 2]\r\n        if (!Guard.isBlockStatement(parent)) return\r\n        if (\r\n          !Guard.isLiteralBoolean(node.test) ||\r\n          node.test.value ||\r\n          node.alternate\r\n        )\r\n          return\r\n\r\n        // dead\r\n\r\n        let ourIdx = parent.body.findIndex(\r\n          (e) =>\r\n            e.type === node.type && e.start === node.start && e.end === node.end\r\n        )\r\n        parent.body.splice(ourIdx, 1)\r\n      },\r\n    })\r\n    walk(context.ast, {\r\n      WhileStatement(node, _, ancestors) {\r\n        const parent = ancestors[ancestors.length - 2]\r\n        if (!Guard.isBlockStatement(parent)) return\r\n        if (!Guard.isLiteralBoolean(node.test) || node.test.value) return\r\n\r\n        let ourIdx = parent.body.findIndex(\r\n          (e) =>\r\n            e.type === node.type && e.start === node.start && e.end === node.end\r\n        )\r\n        parent.body.splice(ourIdx, 1)\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  // remove dead variables (not assigned)\r\n  removeDeadVariables(context: Context) {\r\n    function visitor(func: Function) {\r\n      const scope = context.scopeManager.acquire(func)\r\n      if (!scope) return\r\n\r\n      for (const v of scope.variables) {\r\n        if (v.name === 'arguments') continue\r\n        if (v.identifiers.length !== 1) continue // ?\r\n        if (v.defs.length !== 1) continue // ?\r\n        if (v.defs[0].type !== 'Variable') continue\r\n\r\n        if (v.references.length === 0) {\r\n          let def = v.defs[0]\r\n          let node = def.node as VariableDeclarator\r\n          let p = findNodeAt<VariableDeclaration>(\r\n            func,\r\n            def.parent.range!,\r\n            'VariableDeclaration'\r\n          )\r\n          if (!p) continue // ?\r\n          p.declarations = p.declarations.filter(\r\n            (decl) => decl.start !== node.start && decl.end !== node.end\r\n          )\r\n          context.log('Removed dead variable', v.name)\r\n        }\r\n      }\r\n    }\r\n\r\n    walk(context.ast, {\r\n      FunctionDeclaration: visitor,\r\n      FunctionExpression: visitor,\r\n      ArrowFunctionExpression: visitor,\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.flipIfStatements(context)\r\n      .removeDeadAlternates(context)\r\n      .fixIfStatements(context)\r\n      .removeDead(context)\r\n    //.removeDeadVariables(context)\r\n  }\r\n}\r\n", "import {\r\n  Program,\r\n  BlockStatement,\r\n  sp,\r\n  Function,\r\n  ReturnStatement,\r\n  Statement,\r\n  AssignmentExpression,\r\n  CallExpression,\r\n  FunctionDeclaration,\r\n  Identifier,\r\n  Pattern,\r\n  ExpressionStatement,\r\n  FunctionExpression,\r\n} from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { walk } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\nimport Context from '../context'\r\n\r\nexport interface DemangleOptions extends TransformerOptions {}\r\nexport default class Demangle extends Transformer<DemangleOptions> {\r\n  constructor(options: Partial<DemangleOptions>) {\r\n    super('Demangle', options)\r\n  }\r\n\r\n  // demangles proxy functions to match schema required by StringDecoder\r\n  // for now, only fixes 2 length funcs.\r\n  demangleProxies(context: Context) {\r\n    function visitor(func: Function) {\r\n      if (!Guard.isBlockStatement(func.body)) return\r\n      if (func.body.body.length !== 2) return\r\n      let body = func.body.body\r\n\r\n      // return is (func_name = function(){return any})()\r\n      // callexpression callee AssignmentExpr left Ident right FuncExpression\r\n      if (!Guard.isReturnStatement(body[body.length - 1])) return\r\n      const retn = body[body.length - 1] as ReturnStatement\r\n\r\n      if (!retn.argument) return\r\n      let ae: AssignmentExpression, cx: CallExpression\r\n\r\n      if (Guard.isSequenceExpression(retn.argument)) {\r\n        if (!Guard.isAssignmentExpression(retn.argument.expressions[0])) return\r\n        if (!Guard.isCallExpression(retn.argument.expressions[1])) return\r\n        ae = retn.argument.expressions[0]\r\n        cx = retn.argument.expressions[1]\r\n      } else if (Guard.isCallExpression(retn.argument)) {\r\n        if (!Guard.isAssignmentExpression(retn.argument.callee)) return\r\n        ae = retn.argument.callee\r\n        cx = retn.argument\r\n      } else {\r\n        return\r\n      }\r\n\r\n      if (!Guard.isIdentifier(ae.left)) return\r\n      if (!Guard.isFunctionExpression(ae.right)) return\r\n\r\n      let nb = [\r\n        body[0],\r\n        {\r\n          type: 'ExpressionStatement',\r\n          expression: ae,\r\n        },\r\n        {\r\n          type: 'ReturnStatement',\r\n          argument: {\r\n            type: 'CallExpression',\r\n            callee: {\r\n              type: 'Identifier',\r\n              name: ae.left.name,\r\n            },\r\n            arguments: cx.arguments,\r\n          },\r\n        },\r\n      ]\r\n      // update\r\n      sp<BlockStatement>(func.body, {\r\n        body: nb as Statement[],\r\n      })\r\n    }\r\n    walk(context.ast, {\r\n      FunctionDeclaration: visitor,\r\n      FunctionExpression: visitor,\r\n      ArrowFunctionExpression: visitor,\r\n    })\r\n    return this\r\n  }\r\n\r\n  // moves strArray[(idx - offset)] to an AssignExp above it\r\n  demangleStringFuncs(context: Context) {\r\n    function visitor(func: FunctionDeclaration) {\r\n      if (!Guard.isBlockStatement(func.body)) return\r\n      if (!func.id) return\r\n      if (func.body.body.length !== 3) return\r\n      let body = func.body.body\r\n      if (\r\n        !Guard.isExpressionStatement(body[1]) ||\r\n        !Guard.isAssignmentExpression(body[1].expression)\r\n      )\r\n        return\r\n\r\n      if (!Guard.isIdentifier(body[1].expression.left)) return\r\n      if (body[1].expression.left.name !== func.id.name) return\r\n      if (!Guard.isFunctionExpression(body[1].expression.right)) return\r\n\r\n      let fx = body[1].expression.right,\r\n        fxb = fx.body.body\r\n      let nb: Statement[] = []\r\n      // extracts offset setter\r\n      if (!Guard.isVariableDeclaration(fxb[0])) return\r\n      if (fxb[0].declarations.length !== 1) return\r\n      if (!fxb[0].declarations[0].init) return\r\n      if (!Guard.isMemberExpression(fxb[0].declarations[0].init)) return\r\n      if (!Guard.isAssignmentExpression(fxb[0].declarations[0].init.property))\r\n        return\r\n      if (!Guard.isIdentifier(fxb[0].declarations[0].init.property.left)) return\r\n      if (!Guard.isLiteralNumeric(fxb[0].declarations[0].init.property.right))\r\n        return\r\n      if (fxb[0].declarations[0].init.property.operator !== '-=') return\r\n\r\n      const offsetId = fxb[0].declarations[0].init.property.left.name,\r\n        offsetVal = fxb[0].declarations[0].init.property.right.value\r\n      nb.push({\r\n        type: 'ExpressionStatement',\r\n        expression: {\r\n          type: 'AssignmentExpression',\r\n          operator: '=',\r\n          left: {\r\n            type: 'Identifier',\r\n            name: offsetId,\r\n          },\r\n          right: {\r\n            type: 'BinaryExpression',\r\n            operator: '-',\r\n            left: {\r\n              type: 'Identifier',\r\n              name: offsetId,\r\n            },\r\n            right: {\r\n              type: 'Literal',\r\n              value: offsetVal,\r\n            },\r\n          },\r\n        },\r\n      } as ExpressionStatement)\r\n\r\n      sp<Identifier>(fxb[0].declarations[0].init.property, {\r\n        type: 'Identifier',\r\n        name: offsetId,\r\n      })\r\n      nb = [...nb, ...fxb]\r\n      // this could definitely be wrote better lol\r\n      // this extracts charsets etc\r\n      if (fxb.length >= 3) {\r\n        // possibly B64/RC4 type decoder\r\n        if (Guard.isIfStatement(nb[2])) {\r\n          let ifst = nb[2]\r\n          if (\r\n            Guard.isBlockStatement(ifst.consequent) &&\r\n            ifst.consequent.body.length > 1 // maybe ==2\r\n          ) {\r\n            if (\r\n              (Guard.isVariableDeclaration(ifst.consequent.body[0]) &&\r\n                ifst.consequent.body[0].declarations.length > 0 &&\r\n                ifst.consequent.body[0].declarations[0].init &&\r\n                Guard.isFunctionExpression(\r\n                  ifst.consequent.body[0].declarations[0].init\r\n                )) ||\r\n              (Guard.isExpressionStatement(ifst.consequent.body[0]) &&\r\n                Guard.isAssignmentExpression(\r\n                  ifst.consequent.body[0].expression\r\n                ) &&\r\n                Guard.isMemberExpression(\r\n                  ifst.consequent.body[0].expression.left\r\n                ) &&\r\n                Guard.isIdentifier(\r\n                  ifst.consequent.body[0].expression.left.object\r\n                ) &&\r\n                Guard.isIdentifier(\r\n                  ifst.consequent.body[0].expression.left.property\r\n                ) &&\r\n                Guard.isFunctionExpression(\r\n                  ifst.consequent.body[0].expression.right\r\n                ))\r\n            ) {\r\n              let dfx: FunctionExpression = (\r\n                  Guard.isExpressionStatement(ifst.consequent.body[0])\r\n                    ? (\r\n                        ifst.consequent.body[0]\r\n                          .expression as AssignmentExpression\r\n                      ).right\r\n                    : ifst.consequent.body[0].declarations[0].init\r\n                ) as FunctionExpression,\r\n                dfxb = dfx!.body.body\r\n              if (dfxb.length > 1) {\r\n                if (\r\n                  Guard.isForStatement(dfxb[0]) &&\r\n                  Guard.isBlockStatement(dfxb[0].body)\r\n                ) {\r\n                  if (Guard.isExpressionStatement(dfxb[0].body.body[0])) {\r\n                    if (\r\n                      Guard.isAssignmentExpression(\r\n                        dfxb[0].body.body[0].expression\r\n                      )\r\n                    ) {\r\n                      if (\r\n                        Guard.isCallExpression(\r\n                          dfxb[0].body.body[0].expression.right\r\n                        )\r\n                      ) {\r\n                        if (\r\n                          Guard.isMemberExpression(\r\n                            dfxb[0].body.body[0].expression.right.callee\r\n                          )\r\n                        ) {\r\n                          if (\r\n                            dfxb[0].init &&\r\n                            Guard.isVariableDeclaration(dfxb[0].init)\r\n                          ) {\r\n                            if (\r\n                              dfxb[0].init.declarations[0].init &&\r\n                              Guard.isLiteralString(\r\n                                dfxb[0].init.declarations[0].init\r\n                              )\r\n                            ) {\r\n                              let charset =\r\n                                dfxb[0].init.declarations[0].init.value\r\n                              if (charset.length === 65)\r\n                                dfxb.splice(0, 0, {\r\n                                  type: 'VariableDeclaration',\r\n                                  kind: 'const',\r\n                                  start: 0,\r\n                                  end: 0,\r\n                                  declarations: [\r\n                                    {\r\n                                      type: 'VariableDeclarator',\r\n                                      id: {\r\n                                        type: 'Identifier',\r\n                                        name: 'charset',\r\n                                      } as Pattern,\r\n                                      init: {\r\n                                        type: 'Literal',\r\n                                        value: charset,\r\n                                      },\r\n                                      start: 0,\r\n                                      end: 0,\r\n                                    },\r\n                                  ],\r\n                                })\r\n                            } else if (\r\n                              Guard.isLiteralString(\r\n                                dfxb[0].body.body[0].expression.right.callee\r\n                                  .object\r\n                              ) &&\r\n                              Guard.isIdentifier(\r\n                                dfxb[0].body.body[0].expression.right.callee\r\n                                  .property\r\n                              ) &&\r\n                              dfxb[0].body.body[0].expression.right.callee\r\n                                .property.name === 'indexOf'\r\n                            ) {\r\n                              // this is if the charset gets moved (it won't)\r\n                              // just in case though\r\n                              let charset =\r\n                                dfxb[0].body.body[0].expression.right.callee\r\n                                  .object.value\r\n                              if (charset.length === 65)\r\n                                dfxb.splice(0, 0, {\r\n                                  type: 'VariableDeclaration',\r\n                                  kind: 'const',\r\n                                  start: 0,\r\n                                  end: 0,\r\n                                  declarations: [\r\n                                    {\r\n                                      type: 'VariableDeclarator',\r\n                                      id: {\r\n                                        type: 'Identifier',\r\n                                        name: 'charset',\r\n                                      } as Pattern,\r\n                                      init: {\r\n                                        type: 'Literal',\r\n                                        value: charset,\r\n                                      },\r\n                                      start: 0,\r\n                                      end: 0,\r\n                                    },\r\n                                  ],\r\n                                })\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            // push RC4 function to its own variable\r\n            if (\r\n              Guard.isVariableDeclaration(ifst.consequent.body[0]) &&\r\n              ifst.consequent.body[0].declarations.length === 2\r\n            ) {\r\n              ifst.consequent.body.splice(1, 0, {\r\n                type: 'VariableDeclaration',\r\n                start: 0,\r\n                end: 0,\r\n                kind: ifst.consequent.body[0].kind,\r\n                declarations: [ifst.consequent.body[0].declarations[1]],\r\n              })\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      sp<BlockStatement>(fx.body, {\r\n        body: nb as Statement[],\r\n      })\r\n    }\r\n    walk(context.ast, {\r\n      FunctionDeclaration: visitor,\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.demangleProxies(context).demangleStringFuncs(context)\r\n  }\r\n}\r\n", "import {\r\n  sp,\r\n  Property,\r\n  Literal,\r\n  Function,\r\n  ArrowFunctionExpression,\r\n  FunctionExpression,\r\n  FunctionDeclaration,\r\n  Identifier,\r\n  VariableDeclarator,\r\n  VariableDeclaration,\r\n} from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { walk, findNodeAt } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\nimport Context from '../context'\r\nimport { filterEmptyStatements } from '../util/helpers'\r\n\r\nexport interface ArrayMapOptions extends TransformerOptions {}\r\nexport default class ArrayMap extends Transformer<ArrayMapOptions> {\r\n  constructor(options: Partial<ArrayMapOptions>) {\r\n    super('ArrayMap', options)\r\n  }\r\n\r\n  // demaps arrays that have literals and that start with [null]\r\n  demap(context: Context) {\r\n    function visitor(func: Function) {\r\n      if (!Guard.isBlockStatement(func.body)) return\r\n      const body = filterEmptyStatements(func.body.body)\r\n      if (!body[0]) return\r\n      if (!Guard.isVariableDeclaration(body[0])) return\r\n      const vd = body[0]\r\n      if (vd.declarations.length !== 1) return\r\n      const decl = vd.declarations[0]\r\n      if (!decl.init || !Guard.isArrayExpression(decl.init)) return\r\n      if (decl.init.elements[0] !== null) return\r\n      if (!Guard.isIdentifier(decl.id)) return\r\n      const name = decl.id.name\r\n      let values: (string | number)[] = decl.init.elements.map((el) =>\r\n        el && Guard.isLiteral(el) ? el.value : el\r\n      ) as (string | number)[]\r\n\r\n      walk(func, {\r\n        MemberExpression(mx) {\r\n          if (!Guard.isIdentifier(mx.object)) return\r\n          if (!Guard.isLiteralNumeric(mx.property)) return\r\n          if (mx.object.name !== name) return\r\n          let index = mx.property.value\r\n          if (index >= values.length) return\r\n          let val = values[mx.property.value]\r\n          sp<Literal>(mx, { type: 'Literal', value: val })\r\n        },\r\n      })\r\n      func.body.body = func.body.body.filter(\r\n        (i) => i.start !== vd.start && i.end !== vd.end\r\n      )\r\n    }\r\n    walk(context.ast, {\r\n      FunctionDeclaration: visitor,\r\n      FunctionExpression: visitor,\r\n      ArrowFunctionExpression: visitor,\r\n    })\r\n\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.demap(context)\r\n  }\r\n}\r\n", "import {\r\n  NumericLiteral,\r\n  Literal,\r\n  sp,\r\n  NumericUnaryExpression,\r\n  BinaryOperator,\r\n  Node,\r\n  Identifier,\r\n  BlockStatement,\r\n  Program,\r\n  Function,\r\n} from '../util/types'\r\nimport { Transformer, TransformerOptions } from './transformer'\r\nimport { findNodeAt, walk } from '../util/walk'\r\nimport * as Guard from '../util/guard'\r\n\r\nimport Context from '../context'\r\nimport { Scope } from 'eslint-scope'\r\nimport MersenneTwister from 'mersenne-twister'\r\nimport { generateRandomWords } from '../util/words'\r\n\r\ntype DefinitionType =\r\n  | 'CatchClause'\r\n  | 'ClassName'\r\n  | 'FunctionName'\r\n  | 'ImplicitGlobalVariable'\r\n  | 'ImportBinding'\r\n  | 'Parameter'\r\n  | 'TDZ'\r\n  | 'Variable'\r\n\r\nexport interface RenameOptions extends TransformerOptions {}\r\nexport default class Rename extends Transformer<RenameOptions> {\r\n  mt!: MersenneTwister\r\n  constructor(options: Partial<RenameOptions>) {\r\n    super('Rename', options)\r\n  }\r\n\r\n  getVarPrefix = (type: DefinitionType): string => {\r\n    switch (type) {\r\n      case 'FunctionName':\r\n        return 'func'\r\n      case 'Parameter':\r\n        return 'arg'\r\n      default:\r\n        return 'var'\r\n    }\r\n  }\r\n  getUpperScope = (scope: Scope): Scope | undefined => {\r\n    let upper = scope.upper\r\n    if (!upper) return scope\r\n    if (upper.type === 'global') return scope\r\n    while (upper?.upper?.type !== 'global') {\r\n      upper = upper?.upper!\r\n    }\r\n    return upper\r\n  }\r\n  scopeVisitor = (context: Context, scope: Scope) => {\r\n    let renamed = new Map<string, string>()\r\n    let upperScope = this.getUpperScope(scope)\r\n    if (!upperScope) return // ?\r\n\r\n    for (const v of scope.variables) {\r\n      if (v.name === 'arguments') continue\r\n      let newName =\r\n        this.getVarPrefix(v.defs[0].type) +\r\n        generateRandomWords(this.mt, 2).join('')\r\n      renamed.set(v.name, newName)\r\n      for (const def of v.defs) {\r\n        let ident = findNodeAt<Identifier>(\r\n          context.ast,\r\n          def.name.range!,\r\n          'Identifier'\r\n        )\r\n        if (!ident) continue\r\n        ident.name = newName\r\n      }\r\n      for (const ref of v.references) {\r\n        let ident = findNodeAt<Identifier>(\r\n          context.ast,\r\n          ref.identifier.range!,\r\n          'Identifier'\r\n        )\r\n        if (!ident) continue\r\n        ident.name = newName\r\n      }\r\n      v.name = newName\r\n    }\r\n\r\n    for (const ref of scope.references) {\r\n      let ident = findNodeAt<Identifier>(\r\n        context.ast,\r\n        ref.identifier.range!,\r\n        'Identifier'\r\n      )\r\n      if (!ident) continue\r\n      if (renamed.has(ident.name)) ident.name = renamed.get(ident.name)!\r\n    }\r\n  }\r\n\r\n  public async rename(context: Context) {\r\n    this.mt = new MersenneTwister(context.hash)\r\n    for (const scope of context.scopeManager.scopes) {\r\n      this.scopeVisitor(context, scope)\r\n    }\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.rename(context)\r\n  }\r\n}\r\n", "import MersenneTwister from 'mersenne-twister'\r\nconst wordList = [\r\n  'ability',\r\n  'able',\r\n  'aboard',\r\n  'about',\r\n  'above',\r\n  'accept',\r\n  'accident',\r\n  'according',\r\n  'account',\r\n  'accurate',\r\n  'acres',\r\n  'across',\r\n  'act',\r\n  'action',\r\n  'active',\r\n  'activity',\r\n  'actual',\r\n  'actually',\r\n  'add',\r\n  'addition',\r\n  'additional',\r\n  'adjective',\r\n  'adult',\r\n  'adventure',\r\n  'advice',\r\n  'affect',\r\n  'afraid',\r\n  'after',\r\n  'afternoon',\r\n  'again',\r\n  'against',\r\n  'age',\r\n  'ago',\r\n  'agree',\r\n  'ahead',\r\n  'aid',\r\n  'air',\r\n  'airplane',\r\n  'alike',\r\n  'alive',\r\n  'all',\r\n  'allow',\r\n  'almost',\r\n  'alone',\r\n  'along',\r\n  'aloud',\r\n  'alphabet',\r\n  'already',\r\n  'also',\r\n  'although',\r\n  'am',\r\n  'among',\r\n  'amount',\r\n  'ancient',\r\n  'angle',\r\n  'angry',\r\n  'animal',\r\n  'announced',\r\n  'another',\r\n  'answer',\r\n  'ants',\r\n  'any',\r\n  'anybody',\r\n  'anyone',\r\n  'anything',\r\n  'anyway',\r\n  'anywhere',\r\n  'apart',\r\n  'apartment',\r\n  'appearance',\r\n  'apple',\r\n  'applied',\r\n  'appropriate',\r\n  'are',\r\n  'area',\r\n  'arm',\r\n  'army',\r\n  'around',\r\n  'arrange',\r\n  'arrangement',\r\n  'arrive',\r\n  'arrow',\r\n  'art',\r\n  'article',\r\n  'as',\r\n  'aside',\r\n  'ask',\r\n  'asleep',\r\n  'at',\r\n  'ate',\r\n  'atmosphere',\r\n  'atom',\r\n  'atomic',\r\n  'attached',\r\n  'attack',\r\n  'attempt',\r\n  'attention',\r\n  'audience',\r\n  'author',\r\n  'automobile',\r\n  'available',\r\n  'average',\r\n  'avoid',\r\n  'aware',\r\n  'away',\r\n  'baby',\r\n  'back',\r\n  'bad',\r\n  'badly',\r\n  'bag',\r\n  'balance',\r\n  'ball',\r\n  'balloon',\r\n  'band',\r\n  'bank',\r\n  'bar',\r\n  'bare',\r\n  'bark',\r\n  'barn',\r\n  'base',\r\n  'baseball',\r\n  'basic',\r\n  'basis',\r\n  'basket',\r\n  'bat',\r\n  'battle',\r\n  'be',\r\n  'bean',\r\n  'bear',\r\n  'beat',\r\n  'beautiful',\r\n  'beauty',\r\n  'became',\r\n  'because',\r\n  'become',\r\n  'becoming',\r\n  'bee',\r\n  'been',\r\n  'before',\r\n  'began',\r\n  'beginning',\r\n  'begun',\r\n  'behavior',\r\n  'behind',\r\n  'being',\r\n  'believed',\r\n  'bell',\r\n  'belong',\r\n  'below',\r\n  'belt',\r\n  'bend',\r\n  'beneath',\r\n  'bent',\r\n  'beside',\r\n  'best',\r\n  'bet',\r\n  'better',\r\n  'between',\r\n  'beyond',\r\n  'bicycle',\r\n  'bigger',\r\n  'biggest',\r\n  'bill',\r\n  'birds',\r\n  'birth',\r\n  'birthday',\r\n  'bit',\r\n  'bite',\r\n  'black',\r\n  'blank',\r\n  'blanket',\r\n  'blew',\r\n  'blind',\r\n  'block',\r\n  'blood',\r\n  'blow',\r\n  'blue',\r\n  'board',\r\n  'boat',\r\n  'body',\r\n  'bone',\r\n  'book',\r\n  'border',\r\n  'born',\r\n  'both',\r\n  'bottle',\r\n  'bottom',\r\n  'bound',\r\n  'bow',\r\n  'bowl',\r\n  'box',\r\n  'boy',\r\n  'brain',\r\n  'branch',\r\n  'brass',\r\n  'brave',\r\n  'bread',\r\n  'break',\r\n  'breakfast',\r\n  'breath',\r\n  'breathe',\r\n  'breathing',\r\n  'breeze',\r\n  'brick',\r\n  'bridge',\r\n  'brief',\r\n  'bright',\r\n  'bring',\r\n  'broad',\r\n  'broke',\r\n  'broken',\r\n  'brother',\r\n  'brought',\r\n  'brown',\r\n  'brush',\r\n  'buffalo',\r\n  'build',\r\n  'building',\r\n  'built',\r\n  'buried',\r\n  'burn',\r\n  'burst',\r\n  'bus',\r\n  'bush',\r\n  'business',\r\n  'busy',\r\n  'but',\r\n  'butter',\r\n  'buy',\r\n  'by',\r\n  'cabin',\r\n  'cage',\r\n  'cake',\r\n  'call',\r\n  'calm',\r\n  'came',\r\n  'camera',\r\n  'camp',\r\n  'can',\r\n  'canal',\r\n  'cannot',\r\n  'cap',\r\n  'capital',\r\n  'captain',\r\n  'captured',\r\n  'car',\r\n  'carbon',\r\n  'card',\r\n  'care',\r\n  'careful',\r\n  'carefully',\r\n  'carried',\r\n  'carry',\r\n  'case',\r\n  'cast',\r\n  'castle',\r\n  'cat',\r\n  'catch',\r\n  'cattle',\r\n  'caught',\r\n  'cause',\r\n  'cave',\r\n  'cell',\r\n  'cent',\r\n  'center',\r\n  'central',\r\n  'century',\r\n  'certain',\r\n  'certainly',\r\n  'chain',\r\n  'chair',\r\n  'chamber',\r\n  'chance',\r\n  'change',\r\n  'changing',\r\n  'chapter',\r\n  'character',\r\n  'characteristic',\r\n  'charge',\r\n  'chart',\r\n  'check',\r\n  'cheese',\r\n  'chemical',\r\n  'chest',\r\n  'chicken',\r\n  'chief',\r\n  'child',\r\n  'children',\r\n  'choice',\r\n  'choose',\r\n  'chose',\r\n  'chosen',\r\n  'church',\r\n  'circle',\r\n  'circus',\r\n  'citizen',\r\n  'city',\r\n  'class',\r\n  'classroom',\r\n  'claws',\r\n  'clay',\r\n  'clean',\r\n  'clear',\r\n  'clearly',\r\n  'climate',\r\n  'climb',\r\n  'clock',\r\n  'close',\r\n  'closely',\r\n  'closer',\r\n  'cloth',\r\n  'clothes',\r\n  'clothing',\r\n  'cloud',\r\n  'club',\r\n  'coach',\r\n  'coal',\r\n  'coast',\r\n  'coat',\r\n  'coffee',\r\n  'cold',\r\n  'collect',\r\n  'college',\r\n  'colony',\r\n  'color',\r\n  'column',\r\n  'combination',\r\n  'combine',\r\n  'come',\r\n  'comfortable',\r\n  'coming',\r\n  'command',\r\n  'common',\r\n  'community',\r\n  'company',\r\n  'compare',\r\n  'compass',\r\n  'complete',\r\n  'completely',\r\n  'complex',\r\n  'composed',\r\n  'composition',\r\n  'compound',\r\n  'concerned',\r\n  'condition',\r\n  'congress',\r\n  'connected',\r\n  'consider',\r\n  'consist',\r\n  'consonant',\r\n  'constantly',\r\n  'construction',\r\n  'contain',\r\n  'continent',\r\n  'continued',\r\n  'contrast',\r\n  'control',\r\n  'conversation',\r\n  'cook',\r\n  'cookies',\r\n  'cool',\r\n  'copper',\r\n  'copy',\r\n  'corn',\r\n  'corner',\r\n  'correct',\r\n  'correctly',\r\n  'cost',\r\n  'cotton',\r\n  'could',\r\n  'count',\r\n  'country',\r\n  'couple',\r\n  'courage',\r\n  'course',\r\n  'court',\r\n  'cover',\r\n  'cow',\r\n  'cowboy',\r\n  'crack',\r\n  'cream',\r\n  'create',\r\n  'creature',\r\n  'crew',\r\n  'crop',\r\n  'cross',\r\n  'crowd',\r\n  'cry',\r\n  'cup',\r\n  'curious',\r\n  'current',\r\n  'curve',\r\n  'customs',\r\n  'cut',\r\n  'cutting',\r\n  'daily',\r\n  'damage',\r\n  'dance',\r\n  'danger',\r\n  'dangerous',\r\n  'dark',\r\n  'darkness',\r\n  'date',\r\n  'daughter',\r\n  'dawn',\r\n  'day',\r\n  'dead',\r\n  'deal',\r\n  'dear',\r\n  'death',\r\n  'decide',\r\n  'declared',\r\n  'deep',\r\n  'deeply',\r\n  'deer',\r\n  'definition',\r\n  'degree',\r\n  'depend',\r\n  'depth',\r\n  'describe',\r\n  'desert',\r\n  'design',\r\n  'desk',\r\n  'detail',\r\n  'determine',\r\n  'develop',\r\n  'development',\r\n  'diagram',\r\n  'diameter',\r\n  'did',\r\n  'die',\r\n  'differ',\r\n  'difference',\r\n  'different',\r\n  'difficult',\r\n  'difficulty',\r\n  'dig',\r\n  'dinner',\r\n  'direct',\r\n  'direction',\r\n  'directly',\r\n  'dirt',\r\n  'dirty',\r\n  'disappear',\r\n  'discover',\r\n  'discovery',\r\n  'discuss',\r\n  'discussion',\r\n  'disease',\r\n  'dish',\r\n  'distance',\r\n  'distant',\r\n  'divide',\r\n  'division',\r\n  'do',\r\n  'doctor',\r\n  'does',\r\n  'dog',\r\n  'doing',\r\n  'doll',\r\n  'dollar',\r\n  'done',\r\n  'donkey',\r\n  'door',\r\n  'dot',\r\n  'double',\r\n  'doubt',\r\n  'down',\r\n  'dozen',\r\n  'draw',\r\n  'drawn',\r\n  'dream',\r\n  'dress',\r\n  'drew',\r\n  'dried',\r\n  'drink',\r\n  'drive',\r\n  'driven',\r\n  'driver',\r\n  'driving',\r\n  'drop',\r\n  'dropped',\r\n  'drove',\r\n  'dry',\r\n  'duck',\r\n  'due',\r\n  'dug',\r\n  'dull',\r\n  'during',\r\n  'dust',\r\n  'duty',\r\n  'each',\r\n  'eager',\r\n  'ear',\r\n  'earlier',\r\n  'early',\r\n  'earn',\r\n  'earth',\r\n  'easier',\r\n  'easily',\r\n  'east',\r\n  'easy',\r\n  'eat',\r\n  'eaten',\r\n  'edge',\r\n  'education',\r\n  'effect',\r\n  'effort',\r\n  'egg',\r\n  'eight',\r\n  'either',\r\n  'electric',\r\n  'electricity',\r\n  'element',\r\n  'elephant',\r\n  'eleven',\r\n  'else',\r\n  'empty',\r\n  'end',\r\n  'enemy',\r\n  'energy',\r\n  'engine',\r\n  'engineer',\r\n  'enjoy',\r\n  'enough',\r\n  'enter',\r\n  'entire',\r\n  'entirely',\r\n  'environment',\r\n  'equal',\r\n  'equally',\r\n  'equator',\r\n  'equipment',\r\n  'escape',\r\n  'especially',\r\n  'essential',\r\n  'establish',\r\n  'even',\r\n  'evening',\r\n  'event',\r\n  'eventually',\r\n  'ever',\r\n  'every',\r\n  'everybody',\r\n  'everyone',\r\n  'everything',\r\n  'everywhere',\r\n  'evidence',\r\n  'exact',\r\n  'exactly',\r\n  'examine',\r\n  'example',\r\n  'excellent',\r\n  'except',\r\n  'exchange',\r\n  'excited',\r\n  'excitement',\r\n  'exciting',\r\n  'exclaimed',\r\n  'exercise',\r\n  'exist',\r\n  'expect',\r\n  'experience',\r\n  'experiment',\r\n  'explain',\r\n  'explanation',\r\n  'explore',\r\n  'express',\r\n  'expression',\r\n  'extra',\r\n  'eye',\r\n  'face',\r\n  'facing',\r\n  'fact',\r\n  'factor',\r\n  'factory',\r\n  'failed',\r\n  'fair',\r\n  'fairly',\r\n  'fall',\r\n  'fallen',\r\n  'familiar',\r\n  'family',\r\n  'famous',\r\n  'far',\r\n  'farm',\r\n  'farmer',\r\n  'farther',\r\n  'fast',\r\n  'fastened',\r\n  'faster',\r\n  'fat',\r\n  'father',\r\n  'favorite',\r\n  'fear',\r\n  'feathers',\r\n  'feature',\r\n  'fed',\r\n  'feed',\r\n  'feel',\r\n  'feet',\r\n  'fell',\r\n  'fellow',\r\n  'felt',\r\n  'fence',\r\n  'few',\r\n  'fewer',\r\n  'field',\r\n  'fierce',\r\n  'fifteen',\r\n  'fifth',\r\n  'fifty',\r\n  'fight',\r\n  'fighting',\r\n  'figure',\r\n  'fill',\r\n  'film',\r\n  'final',\r\n  'finally',\r\n  'find',\r\n  'fine',\r\n  'finest',\r\n  'finger',\r\n  'finish',\r\n  'fire',\r\n  'fireplace',\r\n  'firm',\r\n  'first',\r\n  'fish',\r\n  'five',\r\n  'fix',\r\n  'flag',\r\n  'flame',\r\n  'flat',\r\n  'flew',\r\n  'flies',\r\n  'flight',\r\n  'floating',\r\n  'floor',\r\n  'flow',\r\n  'flower',\r\n  'fly',\r\n  'fog',\r\n  'folks',\r\n  'follow',\r\n  'food',\r\n  'foot',\r\n  'football',\r\n  'for',\r\n  'force',\r\n  'foreign',\r\n  'forest',\r\n  'forget',\r\n  'forgot',\r\n  'forgotten',\r\n  'form',\r\n  'former',\r\n  'fort',\r\n  'forth',\r\n  'forty',\r\n  'forward',\r\n  'fought',\r\n  'found',\r\n  'four',\r\n  'fourth',\r\n  'fox',\r\n  'frame',\r\n  'free',\r\n  'freedom',\r\n  'frequently',\r\n  'fresh',\r\n  'friend',\r\n  'friendly',\r\n  'frighten',\r\n  'frog',\r\n  'from',\r\n  'front',\r\n  'frozen',\r\n  'fruit',\r\n  'fuel',\r\n  'full',\r\n  'fully',\r\n  'fun',\r\n  'function',\r\n  'funny',\r\n  'fur',\r\n  'furniture',\r\n  'further',\r\n  'future',\r\n  'gain',\r\n  'game',\r\n  'garage',\r\n  'garden',\r\n  'gas',\r\n  'gasoline',\r\n  'gate',\r\n  'gather',\r\n  'gave',\r\n  'general',\r\n  'generally',\r\n  'gentle',\r\n  'gently',\r\n  'get',\r\n  'getting',\r\n  'giant',\r\n  'gift',\r\n  'girl',\r\n  'give',\r\n  'given',\r\n  'giving',\r\n  'glad',\r\n  'glass',\r\n  'globe',\r\n  'go',\r\n  'goes',\r\n  'gold',\r\n  'golden',\r\n  'gone',\r\n  'good',\r\n  'goose',\r\n  'got',\r\n  'government',\r\n  'grabbed',\r\n  'grade',\r\n  'gradually',\r\n  'grain',\r\n  'grandfather',\r\n  'grandmother',\r\n  'graph',\r\n  'grass',\r\n  'gravity',\r\n  'gray',\r\n  'great',\r\n  'greater',\r\n  'greatest',\r\n  'greatly',\r\n  'green',\r\n  'grew',\r\n  'ground',\r\n  'group',\r\n  'grow',\r\n  'grown',\r\n  'growth',\r\n  'guard',\r\n  'guess',\r\n  'guide',\r\n  'gulf',\r\n  'gun',\r\n  'habit',\r\n  'had',\r\n  'hair',\r\n  'half',\r\n  'halfway',\r\n  'hall',\r\n  'hand',\r\n  'handle',\r\n  'handsome',\r\n  'hang',\r\n  'happen',\r\n  'happened',\r\n  'happily',\r\n  'happy',\r\n  'harbor',\r\n  'hard',\r\n  'harder',\r\n  'hardly',\r\n  'has',\r\n  'hat',\r\n  'have',\r\n  'having',\r\n  'hay',\r\n  'he',\r\n  'headed',\r\n  'heading',\r\n  'health',\r\n  'heard',\r\n  'hearing',\r\n  'heart',\r\n  'heat',\r\n  'heavy',\r\n  'height',\r\n  'held',\r\n  'hello',\r\n  'help',\r\n  'helpful',\r\n  'her',\r\n  'herd',\r\n  'here',\r\n  'herself',\r\n  'hidden',\r\n  'hide',\r\n  'high',\r\n  'higher',\r\n  'highest',\r\n  'highway',\r\n  'hill',\r\n  'him',\r\n  'himself',\r\n  'his',\r\n  'history',\r\n  'hit',\r\n  'hold',\r\n  'hole',\r\n  'hollow',\r\n  'home',\r\n  'honor',\r\n  'hope',\r\n  'horn',\r\n  'horse',\r\n  'hospital',\r\n  'hot',\r\n  'hour',\r\n  'house',\r\n  'how',\r\n  'however',\r\n  'huge',\r\n  'human',\r\n  'hundred',\r\n  'hung',\r\n  'hungry',\r\n  'hunt',\r\n  'hunter',\r\n  'hurried',\r\n  'hurry',\r\n  'hurt',\r\n  'husband',\r\n  'ice',\r\n  'idea',\r\n  'identity',\r\n  'if',\r\n  'ill',\r\n  'image',\r\n  'imagine',\r\n  'immediately',\r\n  'importance',\r\n  'important',\r\n  'impossible',\r\n  'improve',\r\n  'in',\r\n  'inch',\r\n  'include',\r\n  'including',\r\n  'income',\r\n  'increase',\r\n  'indeed',\r\n  'independent',\r\n  'indicate',\r\n  'individual',\r\n  'industrial',\r\n  'industry',\r\n  'influence',\r\n  'information',\r\n  'inside',\r\n  'instance',\r\n  'instant',\r\n  'instead',\r\n  'instrument',\r\n  'interest',\r\n  'interior',\r\n  'into',\r\n  'introduced',\r\n  'invented',\r\n  'involved',\r\n  'iron',\r\n  'is',\r\n  'island',\r\n  'it',\r\n  'its',\r\n  'itself',\r\n  'jack',\r\n  'jar',\r\n  'jet',\r\n  'job',\r\n  'join',\r\n  'joined',\r\n  'journey',\r\n  'joy',\r\n  'judge',\r\n  'jump',\r\n  'jungle',\r\n  'just',\r\n  'keep',\r\n  'kept',\r\n  'key',\r\n  'kids',\r\n  'kill',\r\n  'kind',\r\n  'kitchen',\r\n  'knew',\r\n  'knife',\r\n  'know',\r\n  'knowledge',\r\n  'known',\r\n  'label',\r\n  'labor',\r\n  'lack',\r\n  'lady',\r\n  'laid',\r\n  'lake',\r\n  'lamp',\r\n  'land',\r\n  'language',\r\n  'large',\r\n  'larger',\r\n  'largest',\r\n  'last',\r\n  'late',\r\n  'later',\r\n  'laugh',\r\n  'law',\r\n  'lay',\r\n  'layers',\r\n  'lead',\r\n  'leader',\r\n  'leaf',\r\n  'learn',\r\n  'least',\r\n  'leather',\r\n  'leave',\r\n  'leaving',\r\n  'led',\r\n  'left',\r\n  'leg',\r\n  'length',\r\n  'lesson',\r\n  'let',\r\n  'letter',\r\n  'level',\r\n  'library',\r\n  'lie',\r\n  'life',\r\n  'lift',\r\n  'light',\r\n  'like',\r\n  'likely',\r\n  'limited',\r\n  'line',\r\n  'lion',\r\n  'lips',\r\n  'liquid',\r\n  'list',\r\n  'listen',\r\n  'little',\r\n  'live',\r\n  'living',\r\n  'load',\r\n  'local',\r\n  'locate',\r\n  'location',\r\n  'log',\r\n  'lonely',\r\n  'long',\r\n  'longer',\r\n  'look',\r\n  'loose',\r\n  'lose',\r\n  'loss',\r\n  'lost',\r\n  'lot',\r\n  'loud',\r\n  'love',\r\n  'lovely',\r\n  'low',\r\n  'lower',\r\n  'luck',\r\n  'lucky',\r\n  'lunch',\r\n  'lungs',\r\n  'lying',\r\n  'machine',\r\n  'machinery',\r\n  'mad',\r\n  'made',\r\n  'magic',\r\n  'magnet',\r\n  'mail',\r\n  'main',\r\n  'mainly',\r\n  'major',\r\n  'make',\r\n  'making',\r\n  'man',\r\n  'managed',\r\n  'manner',\r\n  'manufacturing',\r\n  'many',\r\n  'map',\r\n  'mark',\r\n  'market',\r\n  'married',\r\n  'mass',\r\n  'massage',\r\n  'master',\r\n  'material',\r\n  'mathematics',\r\n  'matter',\r\n  'may',\r\n  'maybe',\r\n  'me',\r\n  'meal',\r\n  'mean',\r\n  'means',\r\n  'meant',\r\n  'measure',\r\n  'meat',\r\n  'medicine',\r\n  'meet',\r\n  'melted',\r\n  'member',\r\n  'memory',\r\n  'men',\r\n  'mental',\r\n  'merely',\r\n  'met',\r\n  'metal',\r\n  'method',\r\n  'mice',\r\n  'middle',\r\n  'might',\r\n  'mighty',\r\n  'mile',\r\n  'military',\r\n  'milk',\r\n  'mill',\r\n  'mind',\r\n  'mine',\r\n  'minerals',\r\n  'minute',\r\n  'mirror',\r\n  'missing',\r\n  'mission',\r\n  'mistake',\r\n  'mix',\r\n  'mixture',\r\n  'model',\r\n  'modern',\r\n  'molecular',\r\n  'moment',\r\n  'money',\r\n  'monkey',\r\n  'month',\r\n  'mood',\r\n  'moon',\r\n  'more',\r\n  'morning',\r\n  'most',\r\n  'mostly',\r\n  'mother',\r\n  'motion',\r\n  'motor',\r\n  'mountain',\r\n  'mouse',\r\n  'mouth',\r\n  'move',\r\n  'movement',\r\n  'movie',\r\n  'moving',\r\n  'mud',\r\n  'muscle',\r\n  'music',\r\n  'musical',\r\n  'must',\r\n  'my',\r\n  'myself',\r\n  'mysterious',\r\n  'nails',\r\n  'name',\r\n  'nation',\r\n  'national',\r\n  'native',\r\n  'natural',\r\n  'naturally',\r\n  'nature',\r\n  'near',\r\n  'nearby',\r\n  'nearer',\r\n  'nearest',\r\n  'nearly',\r\n  'necessary',\r\n  'neck',\r\n  'needed',\r\n  'needle',\r\n  'needs',\r\n  'negative',\r\n  'neighbor',\r\n  'neighborhood',\r\n  'nervous',\r\n  'nest',\r\n  'never',\r\n  'new',\r\n  'news',\r\n  'newspaper',\r\n  'next',\r\n  'nice',\r\n  'night',\r\n  'nine',\r\n  'no',\r\n  'nobody',\r\n  'nodded',\r\n  'noise',\r\n  'none',\r\n  'noon',\r\n  'nor',\r\n  'north',\r\n  'nose',\r\n  'not',\r\n  'note',\r\n  'noted',\r\n  'nothing',\r\n  'notice',\r\n  'noun',\r\n  'now',\r\n  'number',\r\n  'numeral',\r\n  'nuts',\r\n  'object',\r\n  'observe',\r\n  'obtain',\r\n  'occasionally',\r\n  'occur',\r\n  'ocean',\r\n  'of',\r\n  'off',\r\n  'offer',\r\n  'office',\r\n  'officer',\r\n  'official',\r\n  'oil',\r\n  'old',\r\n  'older',\r\n  'oldest',\r\n  'on',\r\n  'once',\r\n  'one',\r\n  'only',\r\n  'onto',\r\n  'open',\r\n  'operation',\r\n  'opinion',\r\n  'opportunity',\r\n  'opposite',\r\n  'or',\r\n  'orange',\r\n  'orbit',\r\n  'order',\r\n  'ordinary',\r\n  'organization',\r\n  'organized',\r\n  'origin',\r\n  'original',\r\n  'other',\r\n  'ought',\r\n  'our',\r\n  'ourselves',\r\n  'out',\r\n  'outer',\r\n  'outline',\r\n  'outside',\r\n  'over',\r\n  'own',\r\n  'owner',\r\n  'oxygen',\r\n  'pack',\r\n  'package',\r\n  'page',\r\n  'paid',\r\n  'pain',\r\n  'paint',\r\n  'pair',\r\n  'palace',\r\n  'pale',\r\n  'pan',\r\n  'paper',\r\n  'paragraph',\r\n  'parallel',\r\n  'parent',\r\n  'park',\r\n  'part',\r\n  'particles',\r\n  'particular',\r\n  'particularly',\r\n  'partly',\r\n  'parts',\r\n  'party',\r\n  'pass',\r\n  'passage',\r\n  'past',\r\n  'path',\r\n  'pattern',\r\n  'pay',\r\n  'peace',\r\n  'pen',\r\n  'pencil',\r\n  'people',\r\n  'per',\r\n  'percent',\r\n  'perfect',\r\n  'perfectly',\r\n  'perhaps',\r\n  'period',\r\n  'person',\r\n  'personal',\r\n  'pet',\r\n  'phrase',\r\n  'physical',\r\n  'piano',\r\n  'pick',\r\n  'picture',\r\n  'pictured',\r\n  'pie',\r\n  'piece',\r\n  'pig',\r\n  'pile',\r\n  'pilot',\r\n  'pine',\r\n  'pink',\r\n  'pipe',\r\n  'pitch',\r\n  'place',\r\n  'plain',\r\n  'plan',\r\n  'plane',\r\n  'planet',\r\n  'planned',\r\n  'planning',\r\n  'plant',\r\n  'plastic',\r\n  'plate',\r\n  'plates',\r\n  'play',\r\n  'pleasant',\r\n  'please',\r\n  'pleasure',\r\n  'plenty',\r\n  'plural',\r\n  'plus',\r\n  'pocket',\r\n  'poem',\r\n  'poet',\r\n  'poetry',\r\n  'point',\r\n  'pole',\r\n  'police',\r\n  'policeman',\r\n  'political',\r\n  'pond',\r\n  'pony',\r\n  'pool',\r\n  'poor',\r\n  'popular',\r\n  'population',\r\n  'porch',\r\n  'port',\r\n  'position',\r\n  'positive',\r\n  'possible',\r\n  'possibly',\r\n  'post',\r\n  'pot',\r\n  'potatoes',\r\n  'pound',\r\n  'pour',\r\n  'powder',\r\n  'power',\r\n  'powerful',\r\n  'practical',\r\n  'practice',\r\n  'prepare',\r\n  'present',\r\n  'president',\r\n  'press',\r\n  'pressure',\r\n  'pretty',\r\n  'prevent',\r\n  'previous',\r\n  'price',\r\n  'pride',\r\n  'primitive',\r\n  'principal',\r\n  'principle',\r\n  'printed',\r\n  'private',\r\n  'prize',\r\n  'probably',\r\n  'problem',\r\n  'process',\r\n  'produce',\r\n  'product',\r\n  'production',\r\n  'program',\r\n  'progress',\r\n  'promised',\r\n  'proper',\r\n  'properly',\r\n  'property',\r\n  'protection',\r\n  'proud',\r\n  'prove',\r\n  'provide',\r\n  'public',\r\n  'pull',\r\n  'pupil',\r\n  'pure',\r\n  'purple',\r\n  'purpose',\r\n  'push',\r\n  'put',\r\n  'putting',\r\n  'quarter',\r\n  'queen',\r\n  'question',\r\n  'quick',\r\n  'quickly',\r\n  'quiet',\r\n  'quietly',\r\n  'quite',\r\n  'rabbit',\r\n  'race',\r\n  'radio',\r\n  'railroad',\r\n  'rain',\r\n  'raise',\r\n  'ran',\r\n  'ranch',\r\n  'range',\r\n  'rapidly',\r\n  'rate',\r\n  'rather',\r\n  'raw',\r\n  'rays',\r\n  'reach',\r\n  'read',\r\n  'reader',\r\n  'ready',\r\n  'real',\r\n  'realize',\r\n  'rear',\r\n  'reason',\r\n  'recall',\r\n  'receive',\r\n  'recent',\r\n  'recently',\r\n  'recognize',\r\n  'record',\r\n  'red',\r\n  'refer',\r\n  'refused',\r\n  'region',\r\n  'regular',\r\n  'related',\r\n  'relationship',\r\n  'religious',\r\n  'remain',\r\n  'remarkable',\r\n  'remember',\r\n  'remove',\r\n  'repeat',\r\n  'replace',\r\n  'replied',\r\n  'report',\r\n  'represent',\r\n  'require',\r\n  'research',\r\n  'respect',\r\n  'rest',\r\n  'result',\r\n  'return',\r\n  'review',\r\n  'rhyme',\r\n  'rhythm',\r\n  'rice',\r\n  'rich',\r\n  'ride',\r\n  'riding',\r\n  'right',\r\n  'ring',\r\n  'rise',\r\n  'rising',\r\n  'river',\r\n  'road',\r\n  'roar',\r\n  'rock',\r\n  'rocket',\r\n  'rocky',\r\n  'rod',\r\n  'roll',\r\n  'roof',\r\n  'room',\r\n  'root',\r\n  'rope',\r\n  'rose',\r\n  'rough',\r\n  'round',\r\n  'route',\r\n  'row',\r\n  'rubbed',\r\n  'rubber',\r\n  'rule',\r\n  'ruler',\r\n  'run',\r\n  'running',\r\n  'rush',\r\n  'sad',\r\n  'saddle',\r\n  'safe',\r\n  'safety',\r\n  'said',\r\n  'sail',\r\n  'sale',\r\n  'salmon',\r\n  'salt',\r\n  'same',\r\n  'sand',\r\n  'sang',\r\n  'sat',\r\n  'satellites',\r\n  'satisfied',\r\n  'save',\r\n  'saved',\r\n  'saw',\r\n  'say',\r\n  'scale',\r\n  'scared',\r\n  'scene',\r\n  'school',\r\n  'science',\r\n  'scientific',\r\n  'scientist',\r\n  'score',\r\n  'screen',\r\n  'sea',\r\n  'search',\r\n  'season',\r\n  'seat',\r\n  'second',\r\n  'secret',\r\n  'section',\r\n  'see',\r\n  'seed',\r\n  'seeing',\r\n  'seems',\r\n  'seen',\r\n  'seldom',\r\n  'select',\r\n  'selection',\r\n  'sell',\r\n  'send',\r\n  'sense',\r\n  'sent',\r\n  'sentence',\r\n  'separate',\r\n  'series',\r\n  'serious',\r\n  'serve',\r\n  'service',\r\n  'sets',\r\n  'setting',\r\n  'settle',\r\n  'settlers',\r\n  'seven',\r\n  'several',\r\n  'shade',\r\n  'shadow',\r\n  'shake',\r\n  'shaking',\r\n  'shall',\r\n  'shallow',\r\n  'shape',\r\n  'share',\r\n  'sharp',\r\n  'she',\r\n  'sheep',\r\n  'sheet',\r\n  'shelf',\r\n  'shells',\r\n  'shelter',\r\n  'shine',\r\n  'shinning',\r\n  'ship',\r\n  'shirt',\r\n  'shoe',\r\n  'shoot',\r\n  'shop',\r\n  'shore',\r\n  'short',\r\n  'shorter',\r\n  'shot',\r\n  'should',\r\n  'shoulder',\r\n  'shout',\r\n  'show',\r\n  'shown',\r\n  'shut',\r\n  'sick',\r\n  'sides',\r\n  'sight',\r\n  'sign',\r\n  'signal',\r\n  'silence',\r\n  'silent',\r\n  'silk',\r\n  'silly',\r\n  'silver',\r\n  'similar',\r\n  'simple',\r\n  'simplest',\r\n  'simply',\r\n  'since',\r\n  'sing',\r\n  'single',\r\n  'sink',\r\n  'sister',\r\n  'sit',\r\n  'sitting',\r\n  'situation',\r\n  'six',\r\n  'size',\r\n  'skill',\r\n  'skin',\r\n  'sky',\r\n  'slabs',\r\n  'slave',\r\n  'sleep',\r\n  'slept',\r\n  'slide',\r\n  'slight',\r\n  'slightly',\r\n  'slip',\r\n  'slipped',\r\n  'slope',\r\n  'slow',\r\n  'slowly',\r\n  'small',\r\n  'smaller',\r\n  'smallest',\r\n  'smell',\r\n  'smile',\r\n  'smoke',\r\n  'smooth',\r\n  'snake',\r\n  'snow',\r\n  'so',\r\n  'soap',\r\n  'social',\r\n  'society',\r\n  'soft',\r\n  'softly',\r\n  'soil',\r\n  'solar',\r\n  'sold',\r\n  'soldier',\r\n  'solid',\r\n  'solution',\r\n  'solve',\r\n  'some',\r\n  'somebody',\r\n  'somehow',\r\n  'someone',\r\n  'something',\r\n  'sometime',\r\n  'somewhere',\r\n  'son',\r\n  'song',\r\n  'soon',\r\n  'sort',\r\n  'sound',\r\n  'source',\r\n  'south',\r\n  'southern',\r\n  'space',\r\n  'speak',\r\n  'special',\r\n  'species',\r\n  'specific',\r\n  'speech',\r\n  'speed',\r\n  'spell',\r\n  'spend',\r\n  'spent',\r\n  'spider',\r\n  'spin',\r\n  'spirit',\r\n  'spite',\r\n  'split',\r\n  'spoken',\r\n  'sport',\r\n  'spread',\r\n  'spring',\r\n  'square',\r\n  'stage',\r\n  'stairs',\r\n  'stand',\r\n  'standard',\r\n  'star',\r\n  'stared',\r\n  'start',\r\n  'state',\r\n  'statement',\r\n  'station',\r\n  'stay',\r\n  'steady',\r\n  'steam',\r\n  'steel',\r\n  'steep',\r\n  'stems',\r\n  'step',\r\n  'stepped',\r\n  'stick',\r\n  'stiff',\r\n  'still',\r\n  'stock',\r\n  'stomach',\r\n  'stone',\r\n  'stood',\r\n  'stop',\r\n  'stopped',\r\n  'store',\r\n  'storm',\r\n  'story',\r\n  'stove',\r\n  'straight',\r\n  'strange',\r\n  'stranger',\r\n  'straw',\r\n  'stream',\r\n  'street',\r\n  'strength',\r\n  'stretch',\r\n  'strike',\r\n  'string',\r\n  'strip',\r\n  'strong',\r\n  'stronger',\r\n  'struck',\r\n  'structure',\r\n  'struggle',\r\n  'stuck',\r\n  'student',\r\n  'studied',\r\n  'studying',\r\n  'subject',\r\n  'substance',\r\n  'success',\r\n  'successful',\r\n  'such',\r\n  'sudden',\r\n  'suddenly',\r\n  'sugar',\r\n  'suggest',\r\n  'suit',\r\n  'sum',\r\n  'summer',\r\n  'sun',\r\n  'sunlight',\r\n  'supper',\r\n  'supply',\r\n  'support',\r\n  'suppose',\r\n  'sure',\r\n  'surface',\r\n  'surprise',\r\n  'surrounded',\r\n  'swam',\r\n  'sweet',\r\n  'swept',\r\n  'swim',\r\n  'swimming',\r\n  'swing',\r\n  'swung',\r\n  'syllable',\r\n  'symbol',\r\n  'system',\r\n  'table',\r\n  'tail',\r\n  'take',\r\n  'taken',\r\n  'tales',\r\n  'talk',\r\n  'tall',\r\n  'tank',\r\n  'tape',\r\n  'task',\r\n  'taste',\r\n  'taught',\r\n  'tax',\r\n  'tea',\r\n  'teach',\r\n  'teacher',\r\n  'team',\r\n  'tears',\r\n  'teeth',\r\n  'telephone',\r\n  'television',\r\n  'tell',\r\n  'temperature',\r\n  'ten',\r\n  'tent',\r\n  'term',\r\n  'terrible',\r\n  'test',\r\n  'than',\r\n  'thank',\r\n  'that',\r\n  'thee',\r\n  'them',\r\n  'themselves',\r\n  'then',\r\n  'theory',\r\n  'there',\r\n  'therefore',\r\n  'these',\r\n  'they',\r\n  'thick',\r\n  'thin',\r\n  'thing',\r\n  'think',\r\n  'third',\r\n  'thirty',\r\n  'this',\r\n  'those',\r\n  'thou',\r\n  'though',\r\n  'thought',\r\n  'thousand',\r\n  'thread',\r\n  'three',\r\n  'threw',\r\n  'throat',\r\n  'through',\r\n  'throughout',\r\n  'throw',\r\n  'thrown',\r\n  'thumb',\r\n  'thus',\r\n  'thy',\r\n  'tide',\r\n  'tie',\r\n  'tight',\r\n  'tightly',\r\n  'till',\r\n  'time',\r\n  'tin',\r\n  'tiny',\r\n  'tip',\r\n  'tired',\r\n  'title',\r\n  'to',\r\n  'tobacco',\r\n  'today',\r\n  'together',\r\n  'told',\r\n  'tomorrow',\r\n  'tone',\r\n  'tongue',\r\n  'tonight',\r\n  'too',\r\n  'took',\r\n  'tool',\r\n  'top',\r\n  'topic',\r\n  'torn',\r\n  'total',\r\n  'touch',\r\n  'toward',\r\n  'tower',\r\n  'town',\r\n  'toy',\r\n  'trace',\r\n  'track',\r\n  'trade',\r\n  'traffic',\r\n  'trail',\r\n  'train',\r\n  'transportation',\r\n  'trap',\r\n  'travel',\r\n  'treated',\r\n  'tree',\r\n  'triangle',\r\n  'tribe',\r\n  'trick',\r\n  'tried',\r\n  'trip',\r\n  'troops',\r\n  'tropical',\r\n  'trouble',\r\n  'truck',\r\n  'trunk',\r\n  'truth',\r\n  'try',\r\n  'tube',\r\n  'tune',\r\n  'turn',\r\n  'twelve',\r\n  'twenty',\r\n  'twice',\r\n  'two',\r\n  'type',\r\n  'typical',\r\n  'uncle',\r\n  'under',\r\n  'underline',\r\n  'understanding',\r\n  'unhappy',\r\n  'union',\r\n  'unit',\r\n  'universe',\r\n  'unknown',\r\n  'unless',\r\n  'until',\r\n  'unusual',\r\n  'up',\r\n  'upon',\r\n  'upper',\r\n  'upward',\r\n  'us',\r\n  'use',\r\n  'useful',\r\n  'using',\r\n  'usual',\r\n  'usually',\r\n  'valley',\r\n  'valuable',\r\n  'value',\r\n  'vapor',\r\n  'variety',\r\n  'various',\r\n  'vast',\r\n  'vegetable',\r\n  'verb',\r\n  'vertical',\r\n  'very',\r\n  'vessels',\r\n  'victory',\r\n  'view',\r\n  'village',\r\n  'visit',\r\n  'visitor',\r\n  'voice',\r\n  'volume',\r\n  'vote',\r\n  'vowel',\r\n  'voyage',\r\n  'wagon',\r\n  'wait',\r\n  'walk',\r\n  'wall',\r\n  'want',\r\n  'war',\r\n  'warm',\r\n  'warn',\r\n  'was',\r\n  'wash',\r\n  'waste',\r\n  'watch',\r\n  'water',\r\n  'wave',\r\n  'way',\r\n  'we',\r\n  'weak',\r\n  'wealth',\r\n  'wear',\r\n  'weather',\r\n  'week',\r\n  'weigh',\r\n  'weight',\r\n  'welcome',\r\n  'well',\r\n  'went',\r\n  'were',\r\n  'west',\r\n  'western',\r\n  'wet',\r\n  'whale',\r\n  'what',\r\n  'whatever',\r\n  'wheat',\r\n  'wheel',\r\n  'when',\r\n  'whenever',\r\n  'where',\r\n  'wherever',\r\n  'whether',\r\n  'which',\r\n  'while',\r\n  'whispered',\r\n  'whistle',\r\n  'white',\r\n  'who',\r\n  'whole',\r\n  'whom',\r\n  'whose',\r\n  'why',\r\n  'wide',\r\n  'widely',\r\n  'wife',\r\n  'wild',\r\n  'will',\r\n  'willing',\r\n  'win',\r\n  'wind',\r\n  'window',\r\n  'wing',\r\n  'winter',\r\n  'wire',\r\n  'wise',\r\n  'wish',\r\n  'with',\r\n  'within',\r\n  'without',\r\n  'wolf',\r\n  'women',\r\n  'won',\r\n  'wonder',\r\n  'wonderful',\r\n  'wood',\r\n  'wooden',\r\n  'wool',\r\n  'word',\r\n  'wore',\r\n  'work',\r\n  'worker',\r\n  'world',\r\n  'worried',\r\n  'worry',\r\n  'worse',\r\n  'worth',\r\n  'would',\r\n  'wrapped',\r\n  'write',\r\n  'writer',\r\n  'writing',\r\n  'written',\r\n  'wrong',\r\n  'wrote',\r\n  'yard',\r\n  'year',\r\n  'yellow',\r\n  'yes',\r\n  'yesterday',\r\n  'yet',\r\n  'you',\r\n  'young',\r\n  'younger',\r\n  'your',\r\n  'yourself',\r\n  'youth',\r\n  'zero',\r\n  'zebra',\r\n  'zipper',\r\n  'zoo',\r\n  'zulu',\r\n]\r\n\r\nexport function generateRandomWords(mt: MersenneTwister, length = 4): string[] {\r\n  let words: string[] = []\r\n  for (let i = 0; i < length + 0; ++i) {\r\n    let min = i * (wordList.length / length),\r\n      max = (i + 1) * (wordList.length / length)\r\n    let rand = (mt.random() * (max - min) + min) | 0,\r\n      word = [...wordList[rand]]\r\n    word.unshift(word.shift()!.toUpperCase())\r\n    words.push(word.join(''))\r\n  }\r\n  return words\r\n}\r\n", "import {\r\n  sp,\r\n  Property,\r\n  Literal,\r\n  Function,\r\n  ArrowFunctionExpression,\r\n  FunctionExpression,\r\n  FunctionDeclaration,\r\n  Identifier,\r\n  VariableDeclarator,\r\n  VariableDeclaration,\r\n  BinaryExpression,\r\n  ReturnStatement,\r\n  Expression,\r\n} from '../../util/types'\r\nimport { Transformer, TransformerOptions } from './../transformer'\r\nimport { walk, findNodeAt } from '../../util/walk'\r\nimport * as Guard from '../../util/guard'\r\nimport Context from '../../context'\r\nimport { filterEmptyStatements } from '../../util/helpers'\r\nimport { literalOrUnaryExpressionToNumber } from '../../util/translator'\r\n\r\nconst ALLOWED_OPERATORS = ['+', '-', '*', '/']\r\ntype AllowedOperator = '+' | '-' | '*' | '/'\r\ninterface Operator {\r\n  test: number\r\n  operator: AllowedOperator\r\n  lhsIndex: number\r\n  rhsIndex: number\r\n}\r\n\r\ninterface CalcFunction {\r\n  identifier: string\r\n  operators: Operator[]\r\n  operIndex: number\r\n}\r\n\r\nexport interface JSCCalculatorOptions extends TransformerOptions {}\r\nexport default class JSCCalculator extends Transformer<JSCCalculatorOptions> {\r\n  functions: CalcFunction[] = []\r\n  constructor(options: Partial<JSCCalculatorOptions>) {\r\n    super('JSCCalculator', options)\r\n  }\r\n\r\n  find(context: Context) {\r\n    const { functions } = this\r\n    function visitor(node: FunctionDeclaration | FunctionExpression) {\r\n      let body = filterEmptyStatements(node.body.body)\r\n      if (body.length !== 1) return\r\n      if (!Guard.isSwitchStatement(body[0])) return\r\n      if (!node.id || !Guard.isIdentifier(node.id)) return\r\n      const fnName = node.id.name\r\n      const ss = body[0]\r\n      if (\r\n        !ss.cases.every(\r\n          (c) =>\r\n            c.consequent &&\r\n            c.consequent.length === 1 &&\r\n            Guard.isReturnStatement(c.consequent[0]) &&\r\n            c.consequent[0].argument &&\r\n            Guard.isBinaryExpression(c.consequent[0].argument) &&\r\n            Guard.isIdentifier(c.consequent[0].argument.left) &&\r\n            Guard.isIdentifier(c.consequent[0].argument.right)\r\n        )\r\n      )\r\n        return\r\n\r\n      if (!Guard.isIdentifier(ss.discriminant)) return\r\n      const operatorId = ss.discriminant.name\r\n\r\n      // check for each param being an identifier breaks on spread\r\n      const indices = node.params.map((i) => Guard.isIdentifier(i) && i.name)\r\n      const func: CalcFunction = {\r\n        identifier: fnName,\r\n        operators: [],\r\n        operIndex: indices.findIndex((i) => i === operatorId),\r\n      }\r\n\r\n      for (const c of ss.cases) {\r\n        if (\r\n          !c.test ||\r\n          (!Guard.isLiteralNumeric(c.test) && !Guard.isUnaryExpression(c.test))\r\n        )\r\n          return // intended return\r\n\r\n        let test = literalOrUnaryExpressionToNumber(c.test)\r\n        // checked above in .every\r\n        let binex = (c.consequent[0] as ReturnStatement)\r\n          .argument as BinaryExpression\r\n        if (!ALLOWED_OPERATORS.includes(binex.operator)) return // intended return\r\n        let lhsId = (binex.left as Identifier).name,\r\n          rhsId = (binex.right as Identifier).name\r\n        let lhsIndex = indices.findIndex((i) => i === lhsId),\r\n          rhsIndex = indices.findIndex((i) => i === rhsId)\r\n\r\n        const oper: Operator = {\r\n          test: test,\r\n          operator: binex.operator as AllowedOperator,\r\n          lhsIndex,\r\n          rhsIndex,\r\n        }\r\n        func.operators.push(oper)\r\n      }\r\n\r\n      context.log(\r\n        'Found calculator function id =',\r\n        func.identifier,\r\n        'oper =',\r\n        func.operIndex,\r\n        'opers =',\r\n        func.operators\r\n      )\r\n      functions.push(func)\r\n      //;(node as any).type = 'EmptyStatement'\r\n    }\r\n    walk(context.ast, {\r\n      FunctionDeclaration: visitor,\r\n      FunctionExpression: visitor,\r\n    })\r\n    return this\r\n  }\r\n\r\n  fix(context: Context) {\r\n    const { functions } = this\r\n    walk(context.ast, {\r\n      CallExpression(cx) {\r\n        if (!Guard.isIdentifier(cx.callee)) return\r\n        let fnId = cx.callee.name\r\n        let func: CalcFunction | undefined\r\n        if (!(func = functions.find((f) => f.identifier === fnId))) return\r\n\r\n        let _test = cx.arguments[func.operIndex]\r\n        if (\r\n          !Guard.isLiteralNumeric(_test) &&\r\n          !Guard.isUnaryExpressionNumeric(_test)\r\n        )\r\n          return\r\n        const test = literalOrUnaryExpressionToNumber(_test)\r\n\r\n        const operator = func.operators.find((i) => i.test === test)\r\n        if (!operator) return\r\n        let lhs = cx.arguments[operator.lhsIndex] as Expression,\r\n          rhs = cx.arguments[operator.rhsIndex] as Expression\r\n        sp<BinaryExpression>(cx, {\r\n          type: 'BinaryExpression',\r\n          left: lhs,\r\n          right: rhs,\r\n          operator: operator.operator,\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.find(context).fix(context)\r\n  }\r\n}\r\n", "import {\r\n  sp,\r\n  Property,\r\n  Literal,\r\n  Function,\r\n  ArrowFunctionExpression,\r\n  FunctionExpression,\r\n  FunctionDeclaration,\r\n  Identifier,\r\n  VariableDeclarator,\r\n  VariableDeclaration,\r\n  BinaryExpression,\r\n  ReturnStatement,\r\n  Expression,\r\n  SwitchStatement,\r\n  NumericUnaryExpression,\r\n  NumericLiteral,\r\n  BinaryOperator,\r\n  WhileStatement,\r\n  SequenceExpression,\r\n  ExpressionStatement,\r\n} from '../../util/types'\r\nimport { Transformer, TransformerOptions } from './../transformer'\r\nimport { walk, findNodeAt } from '../../util/walk'\r\nimport * as Guard from '../../util/guard'\r\nimport Context from '../../context'\r\nimport { filterEmptyStatements, immutate } from '../../util/helpers'\r\nimport {\r\n  createLiteral,\r\n  literalOrUnaryExpressionToNumber,\r\n} from '../../util/translator'\r\nimport { mathEval } from '../../util/math'\r\nimport Simplify from '../simplify'\r\nimport escodegen from '@javascript-obfuscator/escodegen'\r\nimport { AssignmentOperator } from 'estree'\r\n\r\nfunction inverseOperator(operator: BinaryOperator) {\r\n  switch (operator) {\r\n    case '+':\r\n      return '-'\r\n    case '-':\r\n      return '+'\r\n    case '/':\r\n      return '*'\r\n    case '*':\r\n      return '/'\r\n    default:\r\n      throw new Error(\"Invalid operator to inverse '\" + operator + \"'\")\r\n  }\r\n}\r\ninterface VarStack {\r\n  [x: string]: number\r\n}\r\nfunction generateCode(ast: Node): string {\r\n  return escodegen.generate(ast as any, {\r\n    sourceMapWithCode: true,\r\n  }).code\r\n}\r\n\r\n// this is hard coded since the values won't be of much use to anyone else\r\nconst DEBUG_LOG = false\r\nfunction log(message?: any, ...optionalParams: any[]) {\r\n  if (DEBUG_LOG) console.log.apply(null, arguments as any)\r\n}\r\n\r\nfunction evaluateAssignmentExpr(\r\n  stack: VarStack,\r\n  vk: string,\r\n  operator: AssignmentOperator,\r\n  value: number\r\n) {\r\n  switch (operator) {\r\n    case '=':\r\n      return (stack[vk] = value)\r\n    case '+=':\r\n      return (stack[vk] += value)\r\n    case '-=':\r\n      return (stack[vk] -= value)\r\n    case '*=':\r\n      return (stack[vk] *= value)\r\n    case '/=':\r\n      return (stack[vk] /= value)\r\n    case '%=':\r\n      return (stack[vk] %= value)\r\n    case '<<=':\r\n      return (stack[vk] <<= value)\r\n    case '>>=':\r\n      return (stack[vk] >>= value)\r\n    case '>>>=':\r\n      return (stack[vk] >>>= value)\r\n    case '&=':\r\n      return (stack[vk] &= value)\r\n    case '^=':\r\n      return (stack[vk] ^= value)\r\n    case '|=':\r\n      return (stack[vk] |= value)\r\n    default:\r\n      throw new Error(\r\n        'Invalid assignment expression operator \"' + operator + '\"'\r\n      )\r\n  }\r\n}\r\nfunction updateIdentifiers(stack: VarStack, obj: any) {\r\n  for (const vk in stack) {\r\n    let value = stack[vk],\r\n      node = createLiteral(value)\r\n\r\n    walk(obj, {\r\n      Identifier(id) {\r\n        if (id.name !== vk) return\r\n        sp<any>(id, node)\r\n      },\r\n    })\r\n  }\r\n  return obj\r\n}\r\n\r\nfunction evaluateBinaryExpr(stack: VarStack, _expr: BinaryExpression): number {\r\n  const st = new Simplify({})\r\n\r\n  let expr = immutate(_expr)\r\n  log('chain =', generateCode(expr))\r\n\r\n  updateIdentifiers(stack, expr)\r\n  st.math(expr)\r\n\r\n  log('new chain =', generateCode(expr))\r\n\r\n  if (!Guard.isLiteralNumeric(expr) && !Guard.isUnaryExpressionNumeric(expr))\r\n    throw new Error(\r\n      'Failed to evaluate chain: chain did not evaluate to number'\r\n    )\r\n  log('value =', literalOrUnaryExpressionToNumber(expr))\r\n  log('='.repeat(32))\r\n  return literalOrUnaryExpressionToNumber(expr)\r\n}\r\n\r\n// don't!\r\nconst MAX_SEQUENCE_ASSIGNMENT_ITERS = 10\r\nfunction evaluateSequenceAssignments(\r\n  stack: VarStack,\r\n  _expr: SequenceExpression\r\n): SequenceExpression {\r\n  const st = new Simplify({})\r\n\r\n  for (const expr of _expr.expressions) {\r\n    if (!Guard.isAssignmentExpression(expr)) {\r\n      updateIdentifiers(stack, expr)\r\n      continue\r\n    }\r\n    if (!Guard.isIdentifier(expr.left)) continue\r\n    if (!(expr.left.name in stack)) continue\r\n    const vk = expr.left.name,\r\n      operator = expr.operator\r\n\r\n    let ie = immutate(expr.right)\r\n    updateIdentifiers(stack, ie)\r\n    log('(1/4) Evaluating', vk, operator, generateCode(ie as any))\r\n\r\n    for (let iters = 0; iters < MAX_SEQUENCE_ASSIGNMENT_ITERS; ++iters) {\r\n      if (Guard.isLiteralNumeric(ie) || Guard.isUnaryExpressionNumeric(ie))\r\n        break\r\n      st.literalComparison(ie)\r\n      log('(2/4) Evaluating', vk, operator, generateCode(ie as any))\r\n\r\n      st.conditionalExpression(ie)\r\n      log('(3/4) Evaluating', vk, operator, generateCode(ie as any))\r\n\r\n      st.math(ie)\r\n      log('(4/4) Evaluating', vk, operator, generateCode(ie as any))\r\n    }\r\n\r\n    if (!Guard.isLiteralNumeric(ie) && !Guard.isUnaryExpressionNumeric(ie))\r\n      throw new Error(\r\n        'Failed to evaluate assignment expression, ie is not a numeric value'\r\n      )\r\n\r\n    log('(4/4) Evaluated', vk, operator, generateCode(ie as unknown as Node))\r\n\r\n    let effect = literalOrUnaryExpressionToNumber(ie)\r\n    evaluateAssignmentExpr(stack, vk, operator, effect)\r\n    log(`stack[${vk}] = ${stack[vk]}`)\r\n    log('='.repeat(32))\r\n    ;(expr as any).type = 'EmptyStatement'\r\n  }\r\n  return _expr\r\n}\r\nexport interface JSCControlFlowOptions extends TransformerOptions {}\r\nexport default class JSCControlFlow extends Transformer<JSCControlFlowOptions> {\r\n  constructor(options: Partial<JSCControlFlowOptions>) {\r\n    super('JSCControlFlow', options)\r\n  }\r\n\r\n  deflatten(context: Context) {\r\n    function visitor(node: Function) {\r\n      const scope = context.scopeManager.acquire(node)\r\n      if (!scope) return\r\n      if (!Guard.isBlockStatement(node.body)) return\r\n      let whiles = node.body.body.filter(\r\n        (i) => i.type === 'WhileStatement'\r\n      ) as WhileStatement[]\r\n      for (const w of whiles) {\r\n        context.log('Found while statement')\r\n        if (!Guard.isBinaryExpression(w.test)) continue\r\n        if (\r\n          !Guard.isLiteralNumeric(w.test.right) &&\r\n          !Guard.isUnaryExpressionNumeric(w.test.right)\r\n        )\r\n          continue\r\n\r\n        const stack: VarStack = {}\r\n\r\n        let bx = w.test,\r\n          additive = false\r\n        while (Guard.isBinaryExpression(bx)) {\r\n          additive = bx.operator === '+'\r\n          if (Guard.isIdentifier(bx.left)) {\r\n            stack[bx.left.name] = bx.left.start\r\n          }\r\n          if (Guard.isIdentifier(bx.right)) {\r\n            stack[bx.right.name] = bx.right.start\r\n          }\r\n          bx = bx.left as BinaryExpression\r\n        }\r\n        if (!additive) continue\r\n        for (const vk in stack) {\r\n          let vref = scope.references.find(\r\n            (i) => i.identifier.range![0] === stack[vk]\r\n          )\r\n          if (!vref) continue\r\n          if (\r\n            !vref.resolved ||\r\n            vref.resolved.defs.length === 0 ||\r\n            vref.resolved.defs[0].type !== 'Variable'\r\n          )\r\n            continue\r\n          let def = vref.resolved.defs[0]\r\n          if (\r\n            !def.node.init ||\r\n            (!Guard.isLiteralNumeric(def.node.init) &&\r\n              !Guard.isUnaryExpressionNumeric(def.node.init))\r\n          )\r\n            continue\r\n          def.parent.declarations = def.parent.declarations.filter(\r\n            (i) =>\r\n              i.range![0] !== def.node.range![0] &&\r\n              i.range![1] !== def.node.range![1]\r\n          )\r\n          stack[vk] = literalOrUnaryExpressionToNumber(def.node.init)\r\n        }\r\n        const endState = literalOrUnaryExpressionToNumber(w.test.right)\r\n        context.log(stack, endState)\r\n\r\n        if (!Guard.isBlockStatement(w.body)) continue\r\n        let ss = w.body.body[w.body.body.length - 1]\r\n        if (!Guard.isSwitchStatement(ss)) continue\r\n        if (!Guard.isIdentifier(ss.discriminant)) continue\r\n        let strt = ss.discriminant.start\r\n        let ref = scope.references.find((i) => i.identifier.range![0] === strt)\r\n        if (\r\n          !ref ||\r\n          !ref.resolved ||\r\n          ref.resolved.defs.length === 0 ||\r\n          ref.resolved.defs[0].type !== 'Variable'\r\n        )\r\n          continue\r\n        let def = ref.resolved.defs[0]\r\n        if (!def.node.init || !Guard.isBinaryExpression(def.node.init)) continue\r\n\r\n        let maxIters = ss.cases.length,\r\n          iter = 0\r\n\r\n        let stateExpr = def.node.init! as BinaryExpression\r\n\r\n        // {...vars +} != {endState}\r\n        let whileStateExpr = w.test.left as BinaryExpression\r\n\r\n        let expressions: Expression[][] = []\r\n\r\n        while (true) {\r\n          if (iter > maxIters) {\r\n            throw new Error(\r\n              `JSconfuser control flow switch calculation failed (iter=${iter}>maxLoops=${maxIters})`\r\n            )\r\n          }\r\n          context.log(`Iteration #${iter + 1}/${maxIters + 1}`)\r\n          let wState = evaluateBinaryExpr(stack, whileStateExpr)\r\n          if (wState === endState) {\r\n            context.log(\r\n              'Switch calculation end',\r\n              wState,\r\n              '===',\r\n              endState,\r\n              'stack =',\r\n              stack\r\n            )\r\n            break\r\n          }\r\n\r\n          let state = evaluateBinaryExpr(stack, stateExpr)\r\n          let errorSuffix = ` (whileState = ${wState}, state = ${state}, stack = ${JSON.stringify(\r\n            stack\r\n          )})`\r\n          let caze = ss.cases.find(\r\n            (i) =>\r\n              i.test &&\r\n              literalOrUnaryExpressionToNumber(i.test as NumericLiteral) ===\r\n                state\r\n          )\r\n          if (!caze) throw new Error('Switch case not found' + errorSuffix)\r\n          if (caze.consequent.length !== 2)\r\n            throw new Error('Switch case is not of \"2\" length' + errorSuffix)\r\n          if (caze.consequent[1].type !== 'BreakStatement')\r\n            throw new Error(\r\n              'Switch case consequent[1] is not a BreakStatement' + errorSuffix\r\n            )\r\n          if (!Guard.isExpressionStatement(caze.consequent[0]))\r\n            throw new Error(\r\n              'Switch case consequent[0] is not an ExpressionStatement' +\r\n                errorSuffix\r\n            )\r\n          if (!Guard.isUnaryExpression(caze.consequent[0].expression))\r\n            throw new Error(\r\n              'Switch case consequent[0]<ExpressionStatement>.expression is not a UnaryExpression' +\r\n                errorSuffix\r\n            )\r\n          if (\r\n            !Guard.isSequenceExpression(caze.consequent[0].expression.argument)\r\n          )\r\n            throw new Error(\r\n              'Switch case consequent[0]<ExpressionStatement>.expression<UnaryExpression> is not a SequenceExpression' +\r\n                errorSuffix\r\n            )\r\n          let sequence = caze.consequent[0].expression.argument\r\n          evaluateSequenceAssignments(stack, sequence)\r\n          sequence.expressions = sequence.expressions.filter(\r\n            (i) => (i as any).type !== 'EmptyStatement'\r\n          )\r\n          expressions.push(sequence.expressions)\r\n          context.log('new stack =', stack)\r\n          iter++\r\n        }\r\n\r\n        sp<SequenceExpression>(w, {\r\n          type: 'SequenceExpression',\r\n          expressions: expressions.flat(),\r\n        })\r\n      }\r\n    }\r\n    walk(context.ast, {\r\n      FunctionDeclaration: visitor,\r\n      FunctionExpression: visitor,\r\n      ArrowFunctionExpression: visitor,\r\n    })\r\n    return this\r\n  }\r\n\r\n  fixSwitch(context: Context) {\r\n    function visitor(node: FunctionDeclaration | FunctionExpression) {\r\n      const scope = context.scopeManager.acquire(node)\r\n      if (!scope) return\r\n      let switches = node.body.body.filter((i) =>\r\n        Guard.isSwitchStatement(i)\r\n      ) as SwitchStatement[]\r\n      for (const ss of switches) {\r\n        if (!Guard.isIdentifier(ss.discriminant)) continue\r\n        let discName = ss.discriminant.name\r\n        let v = scope.variables.find((i) => i.name === discName)\r\n        if (!v) continue\r\n        if (v.defs.length === 0 || v.defs[0].type !== 'Variable') continue\r\n        let def = v.defs[0]\r\n        if (!def.node.init || !Guard.isBinaryExpression(def.node.init)) continue\r\n        let init = def.node.init\r\n        if (\r\n          !ss.cases.every(\r\n            (c) =>\r\n              c.test &&\r\n              (Guard.isUnaryExpressionNumeric(c.test) ||\r\n                Guard.isLiteralNumeric(c.test))\r\n          )\r\n        )\r\n          continue\r\n        let leftTrans = 0,\r\n          leftOper: BinaryOperator = '*',\r\n          rightTrans = 0,\r\n          rightOper: BinaryOperator = '+'\r\n\r\n        if (!Guard.isBinaryExpression(init.left)) continue\r\n        if (\r\n          !Guard.isUnaryExpressionNumeric(init.right) &&\r\n          !Guard.isLiteralNumeric(init.right)\r\n        )\r\n          continue\r\n        if (\r\n          !Guard.isUnaryExpressionNumeric(init.left.right) &&\r\n          !Guard.isLiteralNumeric(init.left.right)\r\n        )\r\n          continue\r\n        if (!Guard.isIdentifier(init.left.left)) continue\r\n\r\n        leftTrans = literalOrUnaryExpressionToNumber(init.left.right)\r\n        leftOper = inverseOperator(init.left.operator)\r\n        rightTrans = literalOrUnaryExpressionToNumber(init.right)\r\n        rightOper = inverseOperator(init.operator)\r\n\r\n        for (const c of ss.cases) {\r\n          let test = literalOrUnaryExpressionToNumber(\r\n            c.test! as NumericUnaryExpression | NumericLiteral\r\n          )\r\n          test = mathEval(\r\n            mathEval(test, rightOper, rightTrans),\r\n            leftOper,\r\n            leftTrans\r\n          )\r\n          sp<Literal>(c.test!, {\r\n            type: 'Literal',\r\n            value: test,\r\n          })\r\n        }\r\n        ss.discriminant.name = init.left.left.name\r\n\r\n        def.parent.declarations = def.parent.declarations.filter(\r\n          (i) =>\r\n            i.range![0] !== def.node.range![0] &&\r\n            i.range![1] !== def.node.range![1]\r\n        )\r\n      }\r\n    }\r\n    walk(context.ast, {\r\n      FunctionDeclaration: visitor,\r\n      FunctionExpression: visitor,\r\n    })\r\n    return this\r\n  }\r\n\r\n  public async transform(context: Context) {\r\n    this.fixSwitch(context).deflatten(context)\r\n  }\r\n}\r\n"],
  "mappings": "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EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAGK,6BAA6B,IAAqB,SAAS,GAAa;AAC7E,MAAI,QAAkB;AACtB,WAAS,IAAI,GAAG,IAAI,SAAS,GAAG,EAAE,GAAG;AACnC,QAAI,MAAM,IAAK,UAAS,SAAS,SAC/B,MAAO,KAAI,KAAM,UAAS,SAAS;AACrC,QAAI,OAAQ,GAAG,WAAY,OAAM,OAAO,MAAO,GAC7C,OAAO,CAAC,GAAG,SAAS;AACtB,SAAK,QAAQ,KAAK,QAAS;AAC3B,UAAM,KAAK,KAAK,KAAK;AAAA;AAEvB,SAAO;AAAA;;;AD94DT,2BAAoC,YAA2B;AAAA,EAE7D,YAAY,SAAiC;AAC3C,UAAM,UAAU;AAGlB,wBAAe,CAAC,SAAiC;AAC/C,cAAQ;AAAA,aACD;AACH,iBAAO;AAAA,aACJ;AACH,iBAAO;AAAA;AAEP,iBAAO;AAAA;AAAA;AAGb,yBAAgB,CAAC,UAAoC;AAhDvD;AAiDI,UAAI,QAAQ,MAAM;AAClB,UAAI,CAAC;AAAO,eAAO;AACnB,UAAI,MAAM,SAAS;AAAU,eAAO;AACpC,aAAO,sCAAO,UAAP,mBAAc,UAAS,UAAU;AACtC,gBAAQ,+BAAO;AAAA;AAEjB,aAAO;AAAA;AAET,wBAAe,CAAC,SAAkB,UAAiB;AACjD,UAAI,UAAU,oBAAI;AAClB,UAAI,aAAa,KAAK,cAAc;AACpC,UAAI,CAAC;AAAY;AAEjB,iBAAW,KAAK,MAAM,WAAW;AAC/B,YAAI,EAAE,SAAS;AAAa;AAC5B,YAAI,UACF,KAAK,aAAa,EAAE,KAAK,GAAG,QAC5B,oBAAoB,KAAK,IAAI,GAAG,KAAK;AACvC,gBAAQ,IAAI,EAAE,MAAM;AACpB,mBAAW,OAAO,EAAE,MAAM;AACxB,cAAI,QAAQ,WACV,QAAQ,KACR,IAAI,KAAK,OACT;AAEF,cAAI,CAAC;AAAO;AACZ,gBAAM,OAAO;AAAA;AAEf,mBAAW,OAAO,EAAE,YAAY;AAC9B,cAAI,QAAQ,WACV,QAAQ,KACR,IAAI,WAAW,OACf;AAEF,cAAI,CAAC;AAAO;AACZ,gBAAM,OAAO;AAAA;AAEf,UAAE,OAAO;AAAA;AAGX,iBAAW,OAAO,MAAM,YAAY;AAClC,YAAI,QAAQ,WACV,QAAQ,KACR,IAAI,WAAW,OACf;AAEF,YAAI,CAAC;AAAO;AACZ,YAAI,QAAQ,IAAI,MAAM;AAAO,gBAAM,OAAO,QAAQ,IAAI,MAAM;AAAA;AAAA;AAAA;AAAA,EAInD,OAAO,SAAkB;AAAA;AACpC,WAAK,KAAK,IAAI,gCAAgB,QAAQ;AACtC,iBAAW,SAAS,QAAQ,aAAa,QAAQ;AAC/C,aAAK,aAAa,SAAS;AAAA;AAE7B,aAAO;AAAA;AAAA;AAAA,EAGI,UAAU,SAAkB;AAAA;AACvC,WAAK,OAAO;AAAA;AAAA;AAAA;;;AEvFhB,IAAM,oBAAoB,CAAC,KAAK,KAAK,KAAK;AAgB1C,kCAA2C,YAAkC;AAAA,EAE3E,YAAY,SAAwC;AAClD,UAAM,iBAAiB;AAFzB,qBAA4B;AAAA;AAAA,EAK5B,KAAK,SAAkB;AACrB,UAAM,EAAE,cAAc;AACtB,qBAAiB,MAAgD;AAC/D,UAAI,OAAO,sBAAsB,KAAK,KAAK;AAC3C,UAAI,KAAK,WAAW;AAAG;AACvB,UAAI,CAAC,AAAM,kBAAkB,KAAK;AAAK;AACvC,UAAI,CAAC,KAAK,MAAM,CAAC,AAAM,aAAa,KAAK;AAAK;AAC9C,YAAM,SAAS,KAAK,GAAG;AACvB,YAAM,KAAK,KAAK;AAChB,UACE,CAAC,GAAG,MAAM,MACR,CAAC,MACC,EAAE,cACF,EAAE,WAAW,WAAW,KACxB,AAAM,kBAAkB,EAAE,WAAW,OACrC,EAAE,WAAW,GAAG,YAChB,AAAM,mBAAmB,EAAE,WAAW,GAAG,aACzC,AAAM,aAAa,EAAE,WAAW,GAAG,SAAS,SAC5C,AAAM,aAAa,EAAE,WAAW,GAAG,SAAS;AAGhD;AAEF,UAAI,CAAC,AAAM,aAAa,GAAG;AAAe;AAC1C,YAAM,aAAa,GAAG,aAAa;AAGnC,YAAM,UAAU,KAAK,OAAO,IAAI,CAAC,MAAM,AAAM,aAAa,MAAM,EAAE;AAClE,YAAM,OAAqB;AAAA,QACzB,YAAY;AAAA,QACZ,WAAW;AAAA,QACX,WAAW,QAAQ,UAAU,CAAC,MAAM,MAAM;AAAA;AAG5C,iBAAW,KAAK,GAAG,OAAO;AACxB,YACE,CAAC,EAAE,QACF,CAAC,AAAM,iBAAiB,EAAE,SAAS,CAAC,AAAM,kBAAkB,EAAE;AAE/D;AAEF,YAAI,OAAO,iCAAiC,EAAE;AAE9C,YAAI,QAAS,EAAE,WAAW,GACvB;AACH,YAAI,CAAC,kBAAkB,SAAS,MAAM;AAAW;AACjD,YAAI,QAAS,MAAM,KAAoB,MACrC,QAAS,MAAM,MAAqB;AACtC,YAAI,WAAW,QAAQ,UAAU,CAAC,MAAM,MAAM,QAC5C,WAAW,QAAQ,UAAU,CAAC,MAAM,MAAM;AAE5C,cAAM,OAAiB;AAAA,UACrB;AAAA,UACA,UAAU,MAAM;AAAA,UAChB;AAAA,UACA;AAAA;AAEF,aAAK,UAAU,KAAK;AAAA;AAGtB,cAAQ,IACN,kCACA,KAAK,YACL,UACA,KAAK,WACL,WACA,KAAK;AAEP,gBAAU,KAAK;AAAA;AAGjB,SAAK,QAAQ,KAAK;AAAA,MAChB,qBAAqB;AAAA,MACrB,oBAAoB;AAAA;AAEtB,WAAO;AAAA;AAAA,EAGT,IAAI,SAAkB;AACpB,UAAM,EAAE,cAAc;AACtB,SAAK,QAAQ,KAAK;AAAA,MAChB,eAAe,IAAI;AACjB,YAAI,CAAC,AAAM,aAAa,GAAG;AAAS;AACpC,YAAI,OAAO,GAAG,OAAO;AACrB,YAAI;AACJ,YAAI,CAAE,QAAO,UAAU,KAAK,CAAC,MAAM,EAAE,eAAe;AAAQ;AAE5D,YAAI,QAAQ,GAAG,UAAU,KAAK;AAC9B,YACE,CAAC,AAAM,iBAAiB,UACxB,CAAC,AAAM,yBAAyB;AAEhC;AACF,cAAM,OAAO,iCAAiC;AAE9C,cAAM,WAAW,KAAK,UAAU,KAAK,CAAC,MAAM,EAAE,SAAS;AACvD,YAAI,CAAC;AAAU;AACf,YAAI,MAAM,GAAG,UAAU,SAAS,WAC9B,MAAM,GAAG,UAAU,SAAS;AAC9B,WAAqB,IAAI;AAAA,UACvB,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,UAAU,SAAS;AAAA;AAAA;AAAA;AAIzB,WAAO;AAAA;AAAA,EAGI,UAAU,SAAkB;AAAA;AACvC,WAAK,KAAK,SAAS,IAAI;AAAA;AAAA;AAAA;;;AC1H3B,uBAAsB;AAGtB,yBAAyB,UAA0B;AACjD,UAAQ;AAAA,SACD;AACH,aAAO;AAAA,SACJ;AACH,aAAO;AAAA,SACJ;AACH,aAAO;AAAA,SACJ;AACH,aAAO;AAAA;AAEP,YAAM,IAAI,MAAM,kCAAkC,WAAW;AAAA;AAAA;AAMnE,sBAAsB,KAAmB;AACvC,SAAO,yBAAU,SAAS,KAAY;AAAA,IACpC,mBAAmB;AAAA,KAClB;AAAA;AAIL,IAAM,YAAY;AAClB,aAAa,YAAkB,gBAAuB;AACpD,MAAI;AAAW,YAAQ,IAAI,MAAM,MAAM;AAAA;AAGzC,gCACE,OACA,IACA,UACA,OACA;AACA,UAAQ;AAAA,SACD;AACH,aAAQ,MAAM,MAAM;AAAA,SACjB;AACH,aAAQ,MAAM,OAAO;AAAA,SAClB;AACH,aAAQ,MAAM,OAAO;AAAA,SAClB;AACH,aAAQ,MAAM,OAAO;AAAA,SAClB;AACH,aAAQ,MAAM,OAAO;AAAA,SAClB;AACH,aAAQ,MAAM,OAAO;AAAA,SAClB;AACH,aAAQ,MAAM,QAAQ;AAAA,SACnB;AACH,aAAQ,MAAM,QAAQ;AAAA,SACnB;AACH,aAAQ,MAAM,SAAS;AAAA,SACpB;AACH,aAAQ,MAAM,OAAO;AAAA,SAClB;AACH,aAAQ,MAAM,OAAO;AAAA,SAClB;AACH,aAAQ,MAAM,OAAO;AAAA;AAErB,YAAM,IAAI,MACR,6CAA6C,WAAW;AAAA;AAAA;AAIhE,2BAA2B,OAAiB,KAAU;AACpD,aAAW,MAAM,OAAO;AACtB,QAAI,QAAQ,MAAM,KAChB,OAAO,cAAc;AAEvB,SAAK,KAAK;AAAA,MACR,WAAW,IAAI;AACb,YAAI,GAAG,SAAS;AAAI;AACpB,WAAQ,IAAI;AAAA;AAAA;AAAA;AAIlB,SAAO;AAAA;AAGT,4BAA4B,OAAiB,OAAiC;AAC5E,QAAM,KAAK,IAAI,SAAS;AAExB,MAAI,OAAO,SAAS;AACpB,MAAI,WAAW,aAAa;AAE5B,oBAAkB,OAAO;AACzB,KAAG,KAAK;AAER,MAAI,eAAe,aAAa;AAEhC,MAAI,CAAC,AAAM,iBAAiB,SAAS,CAAC,AAAM,yBAAyB;AACnE,UAAM,IAAI,MACR;AAEJ,MAAI,WAAW,iCAAiC;AAChD,MAAI,IAAI,OAAO;AACf,SAAO,iCAAiC;AAAA;AAI1C,IAAM,gCAAgC;AACtC,qCACE,OACA,OACoB;AACpB,QAAM,KAAK,IAAI,SAAS;AAExB,aAAW,QAAQ,MAAM,aAAa;AACpC,QAAI,CAAC,AAAM,uBAAuB,OAAO;AACvC,wBAAkB,OAAO;AACzB;AAAA;AAEF,QAAI,CAAC,AAAM,aAAa,KAAK;AAAO;AACpC,QAAI,CAAE,MAAK,KAAK,QAAQ;AAAQ;AAChC,UAAM,KAAK,KAAK,KAAK,MACnB,WAAW,KAAK;AAElB,QAAI,KAAK,SAAS,KAAK;AACvB,sBAAkB,OAAO;AACzB,QAAI,oBAAoB,IAAI,UAAU,aAAa;AAEnD,aAAS,QAAQ,GAAG,QAAQ,+BAA+B,EAAE,OAAO;AAClE,UAAI,AAAM,iBAAiB,OAAO,AAAM,yBAAyB;AAC/D;AACF,SAAG,kBAAkB;AACrB,UAAI,oBAAoB,IAAI,UAAU,aAAa;AAEnD,SAAG,sBAAsB;AACzB,UAAI,oBAAoB,IAAI,UAAU,aAAa;AAEnD,SAAG,KAAK;AACR,UAAI,oBAAoB,IAAI,UAAU,aAAa;AAAA;AAGrD,QAAI,CAAC,AAAM,iBAAiB,OAAO,CAAC,AAAM,yBAAyB;AACjE,YAAM,IAAI,MACR;AAGJ,QAAI,mBAAmB,IAAI,UAAU,aAAa;AAElD,QAAI,SAAS,iCAAiC;AAC9C,2BAAuB,OAAO,IAAI,UAAU;AAC5C,QAAI,SAAS,SAAS,MAAM;AAC5B,QAAI,IAAI,OAAO;AACd,IAAC,KAAa,OAAO;AAAA;AAExB,SAAO;AAAA;AAGT,mCAA4C,YAAmC;AAAA,EAC7E,YAAY,SAAyC;AACnD,UAAM,kBAAkB;AAAA;AAAA,EAG1B,UAAU,SAAkB;AAC1B,qBAAiB,MAAgB;AAC/B,YAAM,QAAQ,QAAQ,aAAa,QAAQ;AAC3C,UAAI,CAAC;AAAO;AACZ,UAAI,CAAC,AAAM,iBAAiB,KAAK;AAAO;AACxC,UAAI,SAAS,KAAK,KAAK,KAAK,OAC1B,CAAC,MAAM,EAAE,SAAS;AAEpB,iBAAW,KAAK,QAAQ;AACtB,gBAAQ,IAAI;AACZ,YAAI,CAAC,AAAM,mBAAmB,EAAE;AAAO;AACvC,YACE,CAAC,AAAM,iBAAiB,EAAE,KAAK,UAC/B,CAAC,AAAM,yBAAyB,EAAE,KAAK;AAEvC;AAEF,cAAM,QAAkB;AAExB,YAAI,KAAK,EAAE,MACT,WAAW;AACb,eAAO,AAAM,mBAAmB,KAAK;AACnC,qBAAW,GAAG,aAAa;AAC3B,cAAI,AAAM,aAAa,GAAG,OAAO;AAC/B,kBAAM,GAAG,KAAK,QAAQ,GAAG,KAAK;AAAA;AAEhC,cAAI,AAAM,aAAa,GAAG,QAAQ;AAChC,kBAAM,GAAG,MAAM,QAAQ,GAAG,MAAM;AAAA;AAElC,eAAK,GAAG;AAAA;AAEV,YAAI,CAAC;AAAU;AACf,mBAAW,MAAM,OAAO;AACtB,cAAI,OAAO,MAAM,WAAW,KAC1B,CAAC,MAAM,EAAE,WAAW,MAAO,OAAO,MAAM;AAE1C,cAAI,CAAC;AAAM;AACX,cACE,CAAC,KAAK,YACN,KAAK,SAAS,KAAK,WAAW,KAC9B,KAAK,SAAS,KAAK,GAAG,SAAS;AAE/B;AACF,cAAI,OAAM,KAAK,SAAS,KAAK;AAC7B,cACE,CAAC,KAAI,KAAK,QACT,CAAC,AAAM,iBAAiB,KAAI,KAAK,SAChC,CAAC,AAAM,yBAAyB,KAAI,KAAK;AAE3C;AACF,eAAI,OAAO,eAAe,KAAI,OAAO,aAAa,OAChD,CAAC,MACC,EAAE,MAAO,OAAO,KAAI,KAAK,MAAO,MAChC,EAAE,MAAO,OAAO,KAAI,KAAK,MAAO;AAEpC,gBAAM,MAAM,iCAAiC,KAAI,KAAK;AAAA;AAExD,cAAM,WAAW,iCAAiC,EAAE,KAAK;AACzD,gBAAQ,IAAI,OAAO;AAEnB,YAAI,CAAC,AAAM,iBAAiB,EAAE;AAAO;AACrC,YAAI,KAAK,EAAE,KAAK,KAAK,EAAE,KAAK,KAAK,SAAS;AAC1C,YAAI,CAAC,AAAM,kBAAkB;AAAK;AAClC,YAAI,CAAC,AAAM,aAAa,GAAG;AAAe;AAC1C,YAAI,OAAO,GAAG,aAAa;AAC3B,YAAI,MAAM,MAAM,WAAW,KAAK,CAAC,MAAM,EAAE,WAAW,MAAO,OAAO;AAClE,YACE,CAAC,OACD,CAAC,IAAI,YACL,IAAI,SAAS,KAAK,WAAW,KAC7B,IAAI,SAAS,KAAK,GAAG,SAAS;AAE9B;AACF,YAAI,MAAM,IAAI,SAAS,KAAK;AAC5B,YAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,AAAM,mBAAmB,IAAI,KAAK;AAAO;AAEhE,YAAI,WAAW,GAAG,MAAM,QACtB,OAAO;AAET,YAAI,YAAY,IAAI,KAAK;AAGzB,YAAI,iBAAiB,EAAE,KAAK;AAE5B,YAAI,cAA8B;AAElC,eAAO,MAAM;AACX,cAAI,OAAO,UAAU;AACnB,kBAAM,IAAI,MACR,2DAA2D,iBAAiB;AAAA;AAGhF,kBAAQ,IAAI,cAAc,OAAO,KAAK,WAAW;AACjD,cAAI,SAAS,mBAAmB,OAAO;AACvC,cAAI,WAAW,UAAU;AACvB,oBAAQ,IACN,0BACA,QACA,OACA,UACA,WACA;AAEF;AAAA;AAGF,cAAI,QAAQ,mBAAmB,OAAO;AACtC,cAAI,cAAc,kBAAkB,mBAAmB,kBAAkB,KAAK,UAC5E;AAEF,cAAI,OAAO,GAAG,MAAM,KAClB,CAAC,MACC,EAAE,QACF,iCAAiC,EAAE,UACjC;AAEN,cAAI,CAAC;AAAM,kBAAM,IAAI,MAAM,0BAA0B;AACrD,cAAI,KAAK,WAAW,WAAW;AAC7B,kBAAM,IAAI,MAAM,qCAAqC;AACvD,cAAI,KAAK,WAAW,GAAG,SAAS;AAC9B,kBAAM,IAAI,MACR,sDAAsD;AAE1D,cAAI,CAAC,AAAM,sBAAsB,KAAK,WAAW;AAC/C,kBAAM,IAAI,MACR,4DACE;AAEN,cAAI,CAAC,AAAM,kBAAkB,KAAK,WAAW,GAAG;AAC9C,kBAAM,IAAI,MACR,uFACE;AAEN,cACE,CAAC,AAAM,qBAAqB,KAAK,WAAW,GAAG,WAAW;AAE1D,kBAAM,IAAI,MACR,2GACE;AAEN,cAAI,WAAW,KAAK,WAAW,GAAG,WAAW;AAC7C,sCAA4B,OAAO;AACnC,mBAAS,cAAc,SAAS,YAAY,OAC1C,CAAC,MAAO,EAAU,SAAS;AAE7B,sBAAY,KAAK,SAAS;AAC1B,kBAAQ,IAAI,eAAe;AAC3B;AAAA;AAGF,WAAuB,GAAG;AAAA,UACxB,MAAM;AAAA,UACN,aAAa,YAAY;AAAA;AAAA;AAAA;AAI/B,SAAK,QAAQ,KAAK;AAAA,MAChB,qBAAqB;AAAA,MACrB,oBAAoB;AAAA,MACpB,yBAAyB;AAAA;AAE3B,WAAO;AAAA;AAAA,EAGT,UAAU,SAAkB;AAC1B,qBAAiB,MAAgD;AAC/D,YAAM,QAAQ,QAAQ,aAAa,QAAQ;AAC3C,UAAI,CAAC;AAAO;AACZ,UAAI,WAAW,KAAK,KAAK,KAAK,OAAO,CAAC,MACpC,AAAM,kBAAkB;AAE1B,iBAAW,MAAM,UAAU;AACzB,YAAI,CAAC,AAAM,aAAa,GAAG;AAAe;AAC1C,YAAI,WAAW,GAAG,aAAa;AAC/B,YAAI,IAAI,MAAM,UAAU,KAAK,CAAC,MAAM,EAAE,SAAS;AAC/C,YAAI,CAAC;AAAG;AACR,YAAI,EAAE,KAAK,WAAW,KAAK,EAAE,KAAK,GAAG,SAAS;AAAY;AAC1D,YAAI,MAAM,EAAE,KAAK;AACjB,YAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,AAAM,mBAAmB,IAAI,KAAK;AAAO;AAChE,YAAI,OAAO,IAAI,KAAK;AACpB,YACE,CAAC,GAAG,MAAM,MACR,CAAC,MACC,EAAE,QACD,CAAM,yBAAyB,EAAE,SAChC,AAAM,iBAAiB,EAAE;AAG/B;AACF,YAAI,YAAY,GACd,WAA2B,KAC3B,aAAa,GACb,YAA4B;AAE9B,YAAI,CAAC,AAAM,mBAAmB,KAAK;AAAO;AAC1C,YACE,CAAC,AAAM,yBAAyB,KAAK,UACrC,CAAC,AAAM,iBAAiB,KAAK;AAE7B;AACF,YACE,CAAC,AAAM,yBAAyB,KAAK,KAAK,UAC1C,CAAC,AAAM,iBAAiB,KAAK,KAAK;AAElC;AACF,YAAI,CAAC,AAAM,aAAa,KAAK,KAAK;AAAO;AAEzC,oBAAY,iCAAiC,KAAK,KAAK;AACvD,mBAAW,gBAAgB,KAAK,KAAK;AACrC,qBAAa,iCAAiC,KAAK;AACnD,oBAAY,gBAAgB,KAAK;AAEjC,mBAAW,KAAK,GAAG,OAAO;AACxB,cAAI,OAAO,iCACT,EAAE;AAEJ,iBAAO,SACL,SAAS,MAAM,WAAW,aAC1B,UACA;AAEF,aAAY,EAAE,MAAO;AAAA,YACnB,MAAM;AAAA,YACN,OAAO;AAAA;AAAA;AAGX,WAAG,aAAa,OAAO,KAAK,KAAK,KAAK;AAEtC,YAAI,OAAO,eAAe,IAAI,OAAO,aAAa,OAChD,CAAC,MACC,EAAE,MAAO,OAAO,IAAI,KAAK,MAAO,MAChC,EAAE,MAAO,OAAO,IAAI,KAAK,MAAO;AAAA;AAAA;AAIxC,SAAK,QAAQ,KAAK;AAAA,MAChB,qBAAqB;AAAA,MACrB,oBAAoB;AAAA;AAEtB,WAAO;AAAA;AAAA,EAGI,UAAU,SAAkB;AAAA;AACvC,WAAK,UAAU,SAAS,UAAU;AAAA;AAAA;AAAA;;;AnB3VtC,qBAA6B;AAAA,EAqB3B,YACE,KACA,cACA,UACA,QACA;AAtBF,yBAAwB;AACxB,wBAA8B;AAC9B,0BAAoC;AACpC,mCAA8C;AAE9C,mCAEI;AAEJ,yBAAyB;AAGzB,qBAAqB;AAGrB,gBAAe;AAQb,SAAK,MAAM;AACX,SAAK,eAAe,KAAK,qBAAqB;AAE9C,SAAK,SAAS;AAEd,SAAK,eAAe,AAAY,oBAAQ,KAAK,KAAK;AAAA,MAChD,YAAY,WAAW,WAAW;AAAA;AAAA;AAAA,EAI/B,IAAI,YAAkB,gBAAuB;AAClD,QAAI,CAAC,KAAK;AAAW;AACrB,YAAQ,IAAI,SAAS,GAAG;AAAA;AAAA,EAGlB,qBACN,MACoC;AACpC,QAAI,eAAmD;AACvD,aAAS,CAAC,MAAM,QAAQ,MAAM;AAC5B,cAAQ,KAAK;AAAA,aACN;AACH,uBAAa,KAAK,IAAI,YAAY;AAClC;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,WAAW;AACjC;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,WAAW;AACjC;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,wBAAwB;AAC9C;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,SAAS;AAC/B;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,cAAc;AACpC;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,SAAS;AAC/B;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,SAAS;AAC/B;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,SAAS;AAC/B;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,OAAO;AAC7B;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,cAAc;AACpC;AAAA,aACG;AACH,uBAAa,KAAK,IAAI,eAAe;AACrC;AAAA;AAEA,gBAAM,IAAI,UACR,gBAAgB;AAAA;AAAA;AAIxB,WAAO;AAAA;AAAA;;;AF7KX,sBAAqB;AAgErB,oBAAoB,KAAa;AAC/B,MAAI,MAAM;AACV,MAAI,SAAS,IAAI;AACjB,SAAO;AAAQ,UAAO,MAAM,KAAM,IAAI,WAAW,EAAE;AACnD,SAAO,QAAQ;AAAA;AAGV,yBAAmB;AAAA,EAAnB,cA7EP;AA8ES,0BAAqC;AAAA,MAC1C,aAAa;AAAA,MACb,2BAA2B;AAAA,MAC3B,oBAAoB;AAAA,MACpB,QAAQ;AAAA,MACR,YAAY;AAAA,MACZ,OAAO;AAAA;AAAA;AAAA,EAGD,aACN,UAAuC,IACnB;AACpB,WAAO,kCAAK,KAAK,iBAAmB;AAAA;AAAA,EAG9B,kBAAkB,SAA4C;AACpE,WAAO;AAAA,MACL,aAAa,QAAQ;AAAA,MACrB,YAAY,QAAQ;AAAA,MAEpB,QAAQ;AAAA;AAAA;AAAA,EAIJ,MACN,OACA,SACA,cACY;AACZ,WAAQ,cAAa,QAAQ,aAAa,OAAO,MAAM,OAAO;AAAA;AAAA,EAGnD,gBACX,MACA,UACkB;AAAA;AAClB,YAAM,UAAU,KAAK,aAAa;AAElC,YAAM,sBAAwC;AAAA,QAC5C,CAAC,YAAY;AAAA,QACb,CAAC,2BAA2B;AAAA,QAC5B,CAAC,cAAc;AAAA,QACf,CAAC,YAAY;AAAA,QACb,CAAC,YAAY;AAAA,QAEb,CAAC,iBAAiB;AAAA,QAElB,CAAC,YAAY;AAAA,QACb,CAAC,2BAA2B;AAAA,QAE5B,CAAC,cAAc;AAAA,QACf,CAAC,eAAe;AAAA,QAChB,CAAC,cAAc;AAAA,QACf,CAAC,2BAA2B;AAAA,QAG5B,CAAC,YAAY;AAAA,QACb,CAAC,YAAY;AAAA,QACb,CAAC,YAAY;AAAA,QACb,CAAC,YAAY;AAAA;AAGf,UAAI,UAAU,IAAI,SAChB,MACA,QAAQ,mBAAmB,SAAS,IAChC,QAAQ,qBACR,qBACJ,QAAQ,eAAe;AAGzB,iBAAW,KAAK,QAAQ,cAAc;AACpC,gBAAQ,IAAI,WAAW,EAAE,MAAM;AAC/B,cAAM,EAAE,UAAU;AAAA;AAGpB,UAAI,QAAQ,QAAQ;AAClB,YAAI,SAAS,0BAAU,SAAS,QAAQ,KAAK;AAAA,UACzC,mBAAmB;AAAA,WAClB,MACH,SAAS,KAAK,MACZ,QACA,KAAK,kBAAkB,UACvB;AAEJ,kBAAU,IAAI,SACZ,QACA,CAAC,CAAC,UAAU,MACZ,QAAQ,eAAe;AAEzB,gBAAQ,OAAO,WAAW;AAC1B,mBAAW,KAAK,QAAQ,cAAc;AACpC,kBAAQ,IAAI,oBAAoB,EAAE,MAAM;AACxC,gBAAM,EAAE,UAAU;AAAA;AAAA;AAItB,aAAO,QAAQ;AAAA;AAAA;AAAA,EAGJ,kBACX,QACA,UACiB;AAAA;AACjB,YAAM,UAAU,KAAK,aAAa;AAClC,YAAM,eAAe,KAAK,kBAAkB;AAC5C,UAAI,MAAM,KAAK,MAAM,QAAQ,cAAc;AAG3C,YAAM,MAAM,KAAK,gBAAgB,KAAK;AAEtC,eAAS,0BAAU,SAAS,KAAK;AAAA,QAC/B,mBAAmB;AAAA,SAClB;AACH,UAAI;AACF,iBAAS,wBAAS,OAAO,QAAQ;AAAA,UAC/B,MAAM;AAAA,UACN,aAAa;AAAA,UAGb,QAAQ,CAAC,MAAM,UAAU;AACvB,gBAAI,OAAM,KAAK,MAAM,MAAM,cAAc;AACzC,gBAAI,QAAQ,2BAA2B;AACrC,mBAAK,MAAa;AAAA,gBAChB,gBAAgB,IAAI;AAClB,sBAAI,GAAG,WAAW,SAAS,kBAAkB;AAC3C,uBAAQ,IAAI,iCACP,GAAG,aADI;AAAA,sBAEV,MAAM;AAAA,sBACN,YAAY;AAAA;AAAA,6BAEL,GAAG,WAAW,SAAS,oBAAoB;AACpD,uBAAQ,IAAI,iCACP,GAAG,aADI;AAAA,sBAEV,MAAM;AAAA,sBACN,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAMtB,mBAAO;AAAA;AAAA;AAAA,eAGJ,KAAP;AAGA,gBAAQ,IAAI;AAAA;AAGd,aAAO;AAAA;AAAA;AAAA;",
  "names": []
}
